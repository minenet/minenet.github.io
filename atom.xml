<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Minenet&#39;s Blog</title>
  
  <subtitle>Record study and growth bit by bit !</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://minenet.github.io/"/>
  <updated>2018-04-19T10:43:50.695Z</updated>
  <id>https://minenet.github.io/</id>
  
  <author>
    <name>Minenet</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2016年终总结</title>
    <link href="https://minenet.github.io/2016/12/31/2016-summary.html"/>
    <id>https://minenet.github.io/2016/12/31/2016-summary.html</id>
    <published>2016-12-31T14:17:38.000Z</published>
    <updated>2018-04-19T10:43:50.695Z</updated>
    
    <content type="html"><![CDATA[<h2 id="过去的一年"><a href="#过去的一年" class="headerlink" title="过去的一年"></a>过去的一年</h2><h3 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h3><p>很惭愧，很遗憾，博客自从实习后就没继续写了，自己还是太懒了，还是总得逼逼自己，变坏容易变好难，2017从逼自己开始！</p><h3 id="学业"><a href="#学业" class="headerlink" title="学业"></a>学业</h3><p>关于研究生学习似乎一直很不满意，在<a href="https://minenet.me/2016/04/19/2015-summary.html" target="_blank" rel="noopener">2015年的总结</a>中我就提到过部分，总是那么难熬，但是坚持下来了。今年上半年还有大量的课程需要完成，对于研究生的课程总是一种不在乎的态度，研究生一年多，在学校里面就上了一堆乱七八糟的课程，没什么卵用，只能无奈的去面对。研究，研究啥了，啥也没研究。空虚中度过，三四月分开始忙活研究生毕业开题的事情，总以为是件很容易的事情，还是有点儿费劲，折腾好几个月，可能是自己不认真的问题，也可能与自己导师之间的历史渊源有关（这个就不想提了，悲伤）。我一直不满意学校对研究生的各种安排，过于形式化，一点作用都不起。比如我们两年毕业的专业硕士，课程安排满满的，一年的课程，上一年的课，对于明年六月毕业的学生，九月份是校招高峰季啊。上一年课，拿什么去找工作，比本科生都不如吧。不知道是出于什么目的，这是我一直吐槽的一点。难道不该给予大量的时间去让学生自由发展吗，不管是自己折腾，还是出去实习，总比被“强奸”在教室里上课强一百倍。我的毕业开题一直由于种种原因拖延到七月底才结束。七月，意味着我的2016年过了一半多了。。。有点悲哀。   </p><h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>七月结束后，八月份纠结着，后面的路该如何走，一边投着实习，一边刷着算法，看书写代码。中间收到几个可以实习的机会，但是由于举棋不定还是放弃了机会。总是想着，九月都是校招的高峰时节了，真的还有必要出去实习吗？实习一个月不仅自己学不到东西，还坑了别人公司。不去实习，自己脑子里又没什么干货，拿什么去找，找什么样的工作。研究生阶段的方向是文本挖掘，自动摘要方向。读了一个研究生总得比本科生稍微有点逼格吧，还是去找一般的开发岗，不是我想要的。因为这意味着我研究生就是混了两年，而且还是拿了一个不知名的文聘，没什么用啊。两年青春光阴可以做很多事情，浪费了实在可惜。就在九月初的时候，我还是决定出去实习，找到了属于自己方向的实习岗，NLP。带着一种甘于现状的心冲去了深圳，开始了实习，匆匆忙忙，不知道对错，其实很多选择并没有对错，只是你选择了，最后你自己有没有让它成为你的正确选择，更在于自己。实习公司虽然是创业公司，但是资源很丰富，有新加坡南洋理工的博士（峰哥）带着我飞，很是nice。作为一个初学者很多不懂，极度渴望收获。实习期间学习了很多在学校里从未接触的知识和技术，感觉很好，自己在峰哥的指引下，也负责了一两个产品的研发，中间很累，尤其十一月，产品要在十一月底在北京开发布会，时间很紧，很多工作需要做，加班在所难免。中间陆陆续续的遇到过很多问题，最后都fix掉了，赶在发布会之前产品正式完全上线。顺利开完发布会。那段时间每天上班到下午就开始头痛，不想干活，茶水间喝点东西了继续，很长时间没有休息，每天趴在床上不想动。这段时间的实习收获技术，收获了很多志同道合的朋友，工作很愉快。最后也顺利拿到了正式入职的机会，这是件很完美的事情。尽管错过了校招，然而做自己想做喜欢做的事情似乎没有比这更好了。其实，中间在没有拿到入职机会之前有过一次请假出去实习，仅仅一次，一是因为事情忙，二是一次没有诚意的面试彻底让我扫兴。那天上午和研发总监请假半天，面试一家表面很牛逼的公司，尼玛去了，才知道是一家产学研基地，环境low死了，面试真是坑死了。按时去了，填了一点资料，然后就在会议室等着面试官来。结果丫的等了快一个小时，想着既然来等等吧，就当一次经历，等来了面试官，结果看了我简历，他说他不是做这个的，然后就是一顿瞎扯，他根本不懂，面个球，听我说了几分钟，说让另一个同事过来面你，没有做过这个，不了解。一会儿了，来了两个，一个装逼的拿着一个mac过来（纯装逼），两个看了看，然后就跟我扯我研究生毕业论文的事情，他问我为么现在还没开始做，我说不着急啊，我心里有安排，然后他就替我着急，说自己读研究生时是多么着急（扯蛋）。然后就跟我谈什么薪资，说他们这里研究生最高才开7.5k，还举了一个在这里工作了五年的本科生，从三千到现在16k，我心里想这也是很呵呵，四五年才这么点，水死了，然后我表示接受不了，拿着东西就走了，尼玛，开不起就不要浪费我时间，最后我还写邮件（HR）水了他们一顿，啥都不懂的一群人不要浪费别人时间，每个人的时间很宝贵。本打算多面几家的，没心情了，后面几家都没去了。后来的后来，想想还是好好安心实习！加油！</p><h3 id="健康"><a href="#健康" class="headerlink" title="健康"></a>健康</h3><p>刚开始上班，可能还是在学校散漫惯了，刚开始的第一个月每天都感觉很累。不想动。每天在公司也是各种零食饮料不限量供应，哎，我承认自己还是很喜欢吃零食，中午吃完就睡，时不时去拿一把零食吃，晚上回去吃完饭就躺在床上了。结果可想而知，养肉了，明显感觉到胖了不少，加上没有锻炼。体重直线上升啊，可怕，一次在一家药店门前称过体重，不敢相信，还跑了家去验证，哎，默默接受了。三个月实习结束，现在回学校处理事情，定下了一个目标，开始节食减肥。每天重度污染的地方还是不出去运动为好，好好在室内吧，蓝瘦香菇。。。。</p><h2 id="新的一年"><a href="#新的一年" class="headerlink" title="新的一年"></a>新的一年</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>2016年是不满意的一年，还过一个小时就是2017年了，新的一年有新的小目标去完成，加油！努力！  </p><ul><li>上半年好好完成学业，顺利毕业。  </li><li>努力学习更多的技术，学习更多机器学习和深度学习相关知识，多看paper，好好完成自己的读书计划，写读书笔记，养成一个好习惯。</li><li>锻炼身体，减肥计划，拥有一个健康的身体！</li><li>努力工作，存技术，涨工资，存钱！<br><img src="/image/sunrise.jpg" class="img-center"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;过去的一年&quot;&gt;&lt;a href=&quot;#过去的一年&quot; class=&quot;headerlink&quot; title=&quot;过去的一年&quot;&gt;&lt;/a&gt;过去的一年&lt;/h2&gt;&lt;h3 id=&quot;写在前面的话&quot;&gt;&lt;a href=&quot;#写在前面的话&quot; class=&quot;headerlink&quot; title=&quot;写
      
    
    </summary>
    
      <category term="Summary" scheme="https://minenet.github.io/categories/Summary/"/>
    
    
  </entry>
  
  <entry>
    <title>线性表的顺序存储(Python实现)</title>
    <link href="https://minenet.github.io/2016/08/30/SqList.html"/>
    <id>https://minenet.github.io/2016/08/30/SqList.html</id>
    <published>2016-08-29T20:08:15.000Z</published>
    <updated>2018-04-19T10:43:50.695Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线性表的顺序存储"><a href="#线性表的顺序存储" class="headerlink" title="线性表的顺序存储"></a>线性表的顺序存储</h2><p>用一段地址连续地存储单元依次存储线性表的数据元素。<br>优点：</p><ol><li>无需增加额外的操作。</li><li>快速存取任一元素。</li></ol><p>缺点：</p><ol><li>插入和删除需要移动大量的元素。</li><li>长度较大时，无法确定存储空间。</li><li>有碎片。</li></ol><p>结构和操作比较简单，不在赘述。Google后，发现Python实现的各种版本都有，有些漏洞百出。虽然原理简单，实现起来还是要花点时间，正好加深Python的学习。过程不在重复，注释和test部分写的很详细，不说了上码。<br>Python实现<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*- </span></span><br><span class="line"><span class="comment"># author：minenet</span></span><br><span class="line"><span class="comment"># date: 2016-8-30 04:15:47 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqList</span><span class="params">(object)</span>:</span></span><br><span class="line"> </span><br><span class="line">    <span class="string">''''' </span></span><br><span class="line"><span class="string">        线性表顺序存储表,线性表第一个元素的下标为1，数组的下标为0</span></span><br><span class="line"><span class="string">    '''</span><span class="string">''</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, maxSize)</span>:</span></span><br><span class="line">        self.maxSize = maxSize <span class="comment"># 存储空间初始分配量</span></span><br><span class="line">        self.data = range(maxSize) <span class="comment">#数组存储元素的最大长度</span></span><br><span class="line">        self.last = <span class="number">-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, key)</span>:</span>  </span><br><span class="line">        <span class="string">'''''索引器 get,实现SqList[key]获得value'''</span>  </span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():  </span><br><span class="line">            <span class="keyword">print</span> <span class="string">'SeqList is empty!'</span>  </span><br><span class="line">            <span class="keyword">return</span>  </span><br><span class="line">        <span class="keyword">elif</span> key &lt; <span class="number">1</span> <span class="keyword">or</span> key &gt; self.last +<span class="number">1</span>:  <span class="comment">#key不在线性表内</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">'the given key is Error'</span>  </span><br><span class="line">            <span class="keyword">return</span>  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            <span class="keyword">return</span> self.data[key<span class="number">-1</span>]</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, value)</span>:</span>  </span><br><span class="line">        <span class="string">'''''索引器 set，实现SqList[key]的赋值'''</span>  </span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():  </span><br><span class="line">            <span class="keyword">print</span> <span class="string">'SeqList is empty!'</span>  </span><br><span class="line">            <span class="keyword">return</span>  </span><br><span class="line">        <span class="keyword">if</span> key &lt; <span class="number">1</span> <span class="keyword">or</span> key &gt; self.last + <span class="number">1</span>:  <span class="comment">#key不在线性表内</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">'the given key is Error'</span>  </span><br><span class="line">            <span class="keyword">return</span>  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            self.data[key<span class="number">-1</span>] = value</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        <span class="string">'''''长度，实现len(SqList)'''</span>  </span><br><span class="line">        length = self.last + <span class="number">1</span>  </span><br><span class="line">        <span class="keyword">return</span> length</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLength</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        <span class="string">'''''顺序表长度'''</span>  </span><br><span class="line">        <span class="keyword">return</span> self.last + <span class="number">1</span>  </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        <span class="string">'''''清空顺序表'''</span>  </span><br><span class="line">        self.last = <span class="number">-1</span>  </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        <span class="string">'''''顺序表是否为空'''</span>  </span><br><span class="line">        <span class="keyword">if</span> self.last == <span class="number">-1</span>:  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span>  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span>  </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isFull</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        <span class="string">'''''判断顺序表是否满了'''</span>  </span><br><span class="line">        <span class="keyword">if</span> self.last == self.maxSize - <span class="number">1</span>:  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span>  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span>  </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getElem</span><span class="params">(self, index)</span>:</span>  </span><br><span class="line">        <span class="string">'''''根据索引获取元素'''</span>  </span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():  </span><br><span class="line">            <span class="keyword">print</span> <span class="string">'SeqList is empty!'</span>  </span><br><span class="line">        <span class="keyword">elif</span> index &lt; <span class="number">1</span> <span class="keyword">or</span> index &gt; self.last + <span class="number">1</span>:  </span><br><span class="line">            <span class="keyword">print</span> <span class="string">'Position is error'</span>  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            <span class="keyword">return</span> self.data[index<span class="number">-1</span>]  </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIndex</span><span class="params">(self, elem)</span>:</span>  </span><br><span class="line">        <span class="string">'''''根据元素获取索引'''</span>  </span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():  </span><br><span class="line">            <span class="keyword">print</span> <span class="string">'SeqList is empty!'</span>  </span><br><span class="line">            <span class="keyword">return</span>  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(self.last + <span class="number">1</span>):  </span><br><span class="line">                <span class="keyword">if</span> self.data[i] == elem:  </span><br><span class="line">                    <span class="keyword">return</span> i + <span class="number">1</span> </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, elem)</span>:</span>  </span><br><span class="line">        <span class="string">'''''向顺序表尾插入一个元素'''</span>  </span><br><span class="line">        <span class="keyword">if</span> self.isFull():  </span><br><span class="line">            <span class="keyword">print</span> <span class="string">'SeqList is full'</span>  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            self.last += <span class="number">1</span>  </span><br><span class="line">            self.data[self.last] = elem  </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, index, elem)</span>:</span>  </span><br><span class="line">        <span class="string">'''''</span></span><br><span class="line"><span class="string">        初始条件:顺序线性表已存在， 1 &lt;= index &lt;= self.last + 1</span></span><br><span class="line"><span class="string">        操作结果:在index前面插入新元素，并长度加1 </span></span><br><span class="line"><span class="string">        '''</span>  </span><br><span class="line">        <span class="keyword">if</span> self.isFull():  </span><br><span class="line">            <span class="keyword">print</span> <span class="string">'SeqList is full'</span>  </span><br><span class="line">            <span class="keyword">return</span>  </span><br><span class="line">        <span class="keyword">elif</span> index &lt; <span class="number">1</span> <span class="keyword">or</span> index &gt; self.last + <span class="number">1</span>:  </span><br><span class="line">            <span class="keyword">print</span> <span class="string">'Position is error'</span>  </span><br><span class="line">            <span class="keyword">return</span>  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(self.last, index<span class="number">-2</span>, <span class="number">-1</span>):  <span class="comment">#index-1位置后面的全部元素往后移动1位</span></span><br><span class="line">                self.data[i + <span class="number">1</span>] = self.data[i]  </span><br><span class="line">            self.data[index<span class="number">-1</span>] = elem  <span class="comment">#插入</span></span><br><span class="line">            self.last += <span class="number">1</span>  <span class="comment">#长度加1</span></span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self, index)</span>:</span>  </span><br><span class="line">        <span class="string">'''''删除元素'''</span>  </span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():  </span><br><span class="line">            <span class="keyword">print</span> <span class="string">"SeqList is empty"</span>  </span><br><span class="line">            <span class="keyword">return</span>  </span><br><span class="line">        <span class="keyword">elif</span> index &lt; <span class="number">1</span> <span class="keyword">or</span> index &gt; self.last + <span class="number">1</span>:  </span><br><span class="line">            <span class="keyword">print</span> <span class="string">'Position is error'</span>  </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(index, self.last+<span class="number">1</span>): <span class="comment">#index后面的元素全部往前移动一位。</span></span><br><span class="line">                self.data[i<span class="number">-1</span>] = self.data[i]</span><br><span class="line">            self.last -= <span class="number">1</span></span><br></pre></td></tr></table></figure></p><h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">s = SqList(<span class="number">5</span>) <span class="comment"># data = [0, 1, 2, 3, 4]   s = None</span></span><br><span class="line">s.append(<span class="number">5</span>)   <span class="comment"># data = [5, 1, 2, 3, 4]     s = [5]</span></span><br><span class="line">s.insert(<span class="number">1</span>, <span class="number">6</span>) <span class="comment"># data = [6, 5, 2, 3, 4]  s = [6, 5]</span></span><br><span class="line">s.insert(<span class="number">1</span>, <span class="number">7</span>) <span class="comment"># data = [7, 6, 5, 3, 4]   s = [7, 6, 5]</span></span><br><span class="line"></span><br><span class="line">s.insert(<span class="number">2</span>,<span class="number">11</span>)  <span class="comment"># data = [7, 11, 6, 5, 4]    s = [7, 11, 6, 5]</span></span><br><span class="line"></span><br><span class="line">s.delete(<span class="number">3</span>)  <span class="comment"># data = [7, 11, 5, 5, 4]   s = [7, 11, 5]</span></span><br><span class="line"></span><br><span class="line">s.getIndex(<span class="number">7</span>) <span class="comment"># 1</span></span><br><span class="line">s.getElem(<span class="number">2</span>) <span class="comment"># 11</span></span><br><span class="line">s.getLength() <span class="comment"># 3</span></span><br><span class="line">s[<span class="number">2</span>] = <span class="number">99</span> <span class="comment"># data = [7, 99, 5, 5, 4]  s = [7, 99, 5]</span></span><br><span class="line">s.clear() <span class="comment"># data = [7, 99, 5, 5, 4]   s = None</span></span><br><span class="line">len(s) <span class="comment"># 0</span></span><br></pre></td></tr></table></figure><p>插入和删除的时间的复杂度O(n)。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;线性表的顺序存储&quot;&gt;&lt;a href=&quot;#线性表的顺序存储&quot; class=&quot;headerlink&quot; title=&quot;线性表的顺序存储&quot;&gt;&lt;/a&gt;线性表的顺序存储&lt;/h2&gt;&lt;p&gt;用一段地址连续地存储单元依次存储线性表的数据元素。&lt;br&gt;优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="Python" scheme="https://minenet.github.io/categories/Python/"/>
    
    
      <category term="DataStructure" scheme="https://minenet.github.io/tags/DataStructure/"/>
    
  </entry>
  
  <entry>
    <title>排序算法总结</title>
    <link href="https://minenet.github.io/2016/08/24/sort-summary.html"/>
    <id>https://minenet.github.io/2016/08/24/sort-summary.html</id>
    <published>2016-08-24T08:13:14.000Z</published>
    <updated>2018-04-19T10:43:50.694Z</updated>
    
    <content type="html"><![CDATA[<h2 id="排序总结"><a href="#排序总结" class="headerlink" title="排序总结"></a>排序总结</h2><p>这几天一直在写排算法，这属于最基本的算法，以前只是知道，也没怎么用过，最近重新温故复习，总结一下。<br>其实排序分为内部排序和外部排序，区别在于是否将排序记录全部放置在内存中，外部排序主要用于大量数据的排序，如多路归并排序。最近几天写的都是内部排序。主要可以分为四类：</p><ol><li>插入类排序：直接插入排序和希尔排序。</li><li>选择类排序：简单选择排序和堆排序。</li><li>交换排序类：冒泡排序和快速排序。</li><li>归并类排序：归并排序。</li></ol><p>简单的算法：冒泡、简单选择、直接插入。<br>改进的算法：希尔、堆、归并、快速。  </p><h3 id="算法指标对比"><a href="#算法指标对比" class="headerlink" title="算法指标对比"></a>算法指标对比</h3><table><thead><tr><th style="text-align:center">排序方法</th><th style="text-align:center">平均情况</th><th style="text-align:center">最好情况</th><th style="text-align:center">最坏情况</th><th style="text-align:center">辅助空间</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">冒泡排序</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(1)</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">简单选择排序</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(1)</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">直接插入排序</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(1)</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">希尔排序</td><td style="text-align:center">O(nlogn)~O(n^2)</td><td style="text-align:center">O(n^3/2)</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(1)</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">堆排序</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">O(1)</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">归并排序</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">O(1)</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">快速排序</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(logn)~O(n)</td><td style="text-align:center">不稳定</td></tr></tbody></table><p>算法的选择则需要根据需要选择，比如追求稳定性来说归并排序是个好选择，但是会牺牲空间复杂度。 再比如数据量不大但是关键字信息量大（如数字很大），交换和移动次数多则会耗费和迪诺时间，此时应该选择移动次数较少的简单排序算法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;排序总结&quot;&gt;&lt;a href=&quot;#排序总结&quot; class=&quot;headerlink&quot; title=&quot;排序总结&quot;&gt;&lt;/a&gt;排序总结&lt;/h2&gt;&lt;p&gt;这几天一直在写排算法，这属于最基本的算法，以前只是知道，也没怎么用过，最近重新温故复习，总结一下。&lt;br&gt;其实排序分为内部排
      
    
    </summary>
    
      <category term="Algorithms" scheme="https://minenet.github.io/categories/Algorithms/"/>
    
    
  </entry>
  
  <entry>
    <title>快速排序&amp;寻找第k大的数</title>
    <link href="https://minenet.github.io/2016/08/24/quickSort.html"/>
    <id>https://minenet.github.io/2016/08/24/quickSort.html</id>
    <published>2016-08-23T17:49:31.000Z</published>
    <updated>2018-04-19T10:43:50.694Z</updated>
    
    <content type="html"><![CDATA[<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序的基本思想：通过一趟排序将待排序记录分割成独立的两部分，其中一部分记录的元素均比另一部分记录的元素要小，则可分别对这两部分记录继续进行排序，直到整个序列有序为止。  </p><ol><li>首先选取基准元素（首元素，中间元素，最后元素，随机元素等等）。</li><li>以基准元素为基准，将小于基准元素的元素放在前面，大于基准元素的放在后面。</li><li>然后以基准元素为界限，分为两组数据。</li><li>两组元素重复2和3步骤，直至比较排序完成。<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span><span class="params">(arr, left, right)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> left &gt;= right:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    key = arr[left]</span><br><span class="line">    low = left</span><br><span class="line">    high = right</span><br><span class="line">    <span class="keyword">while</span> low &lt; high:</span><br><span class="line">        <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> arr[high] &gt;= key:</span><br><span class="line">            high -= <span class="number">1</span></span><br><span class="line">        arr[low], arr[high] = arr[high], arr[low]</span><br><span class="line">        <span class="comment"># print arr,low, high</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> arr[low] &lt;= key:</span><br><span class="line">            low += <span class="number">1</span></span><br><span class="line">        arr[low], arr[high] = arr[high], arr[low]</span><br><span class="line">        <span class="comment"># print arr,low, high</span></span><br><span class="line">    quickSort(arr, left, low<span class="number">-1</span>)</span><br><span class="line">    quickSort(arr, low+<span class="number">1</span>, right)</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure></li></ol><p><strong>test</strong><br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">lists = [<span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">0</span>]</span><br><span class="line"><span class="keyword">print</span> quickSort(lists,<span class="number">0</span>,<span class="number">9</span>)</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">[<span class="number">0</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">2</span>] <span class="number">0</span> <span class="number">9</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">9</span>] <span class="number">1</span> <span class="number">9</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">9</span>] <span class="number">1</span> <span class="number">2</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">9</span>] <span class="number">2</span> <span class="number">2</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">9</span>] <span class="number">0</span> <span class="number">0</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">9</span>] <span class="number">0</span> <span class="number">0</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">9</span>] <span class="number">3</span> <span class="number">3</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">9</span>] <span class="number">3</span> <span class="number">3</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>] <span class="number">4</span> <span class="number">8</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>] <span class="number">8</span> <span class="number">8</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>] <span class="number">4</span> <span class="number">5</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>] <span class="number">5</span> <span class="number">5</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>] <span class="number">6</span> <span class="number">7</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>] <span class="number">7</span> <span class="number">7</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure></p><p><strong>应用</strong><br>快排的最坏运行时间为O(n^2)，平均运行时间为O(nlogn)。由于跳跃式交换比较，故不稳定！<br><strong>寻找第k大的数 or 寻找最小的k个数</strong><br>快速排序中我们确定基准值后，将数组分为两部分，基准元素前面一定小于基准元素。后面的大学基准元素。如果基准元素前面的元素个数大于k个，则在k大的书一定在基准元素的前面，且后面的排序没有必要。否则就在后面，前面的排序没必要。直到找个基准元素的位置刚好是k-1。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findTheKNum</span><span class="params">(arr,length,k)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> arr == <span class="keyword">None</span> <span class="keyword">or</span> length &lt; k <span class="keyword">or</span> k &lt;= <span class="number">0</span> <span class="keyword">or</span> length &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    index = partition(arr, <span class="number">0</span>, length<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">while</span> k<span class="number">-1</span> <span class="keyword">is</span> <span class="keyword">not</span> index:</span><br><span class="line">        <span class="keyword">if</span> k<span class="number">-1</span> &lt; index:</span><br><span class="line">            index = partition(arr, <span class="number">0</span>, index<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            index = partition(arr, index+<span class="number">1</span>, length<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> arr[k<span class="number">-1</span>] <span class="comment">#寻找最小的k个数则返回arr[:k]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(arr, low, high)</span>:</span></span><br><span class="line">    key = arr[low]</span><br><span class="line">    <span class="keyword">while</span> low &lt; high:</span><br><span class="line">        <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> arr[high] &gt;= key:</span><br><span class="line">            high -= <span class="number">1</span></span><br><span class="line">        arr[low], arr[high] = arr[high], arr[low]</span><br><span class="line">        <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> arr[low] &lt;= key:</span><br><span class="line">            low += <span class="number">1</span></span><br><span class="line">        arr[low], arr[high] = arr[high], arr[low]</span><br><span class="line">    <span class="keyword">return</span> low</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;快速排序&quot;&gt;&lt;a href=&quot;#快速排序&quot; class=&quot;headerlink&quot; title=&quot;快速排序&quot;&gt;&lt;/a&gt;快速排序&lt;/h2&gt;&lt;p&gt;快速排序的基本思想：通过一趟排序将待排序记录分割成独立的两部分，其中一部分记录的元素均比另一部分记录的元素要小，则可分别对这
      
    
    </summary>
    
      <category term="Algorithms" scheme="https://minenet.github.io/categories/Algorithms/"/>
    
    
  </entry>
  
  <entry>
    <title>归并排序&amp;数组的逆序对</title>
    <link href="https://minenet.github.io/2016/08/23/mergeSort.html"/>
    <id>https://minenet.github.io/2016/08/23/mergeSort.html</id>
    <published>2016-08-22T19:52:55.000Z</published>
    <updated>2018-04-19T10:43:50.694Z</updated>
    
    <content type="html"><![CDATA[<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>建立在归并操作上的一种有效的排序算法,该算法是采用分治法。以二路归并为例。<br>二路归并就是讲含有n个数据的序列看成是n个子记录，每个子记录为1，然后两两归并，最后得到两个已经排好序的子序列，然后做一次归并完成一个长度为n的序列。<br><strong>分治</strong></p><ol><li>将n个序列以n/2为界，分为两个子序列。</li><li>然后通过递归最后分治成只有一个的子序列。</li><li>然后两两递归合并并排序，最后归并完成一个完整的有序序列。<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    length = len(arr)</span><br><span class="line">    <span class="keyword">if</span> length &lt;= <span class="number">1</span> <span class="keyword">or</span> arr == <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    num = length / <span class="number">2</span></span><br><span class="line">    left = mergeSort(arr[:num])</span><br><span class="line">    right = mergeSort(arr[num:])</span><br><span class="line">    <span class="comment">#print left,right</span></span><br><span class="line">    <span class="keyword">return</span> merge(left, right)</span><br></pre></td></tr></table></figure></li></ol><p><strong>归并</strong><br>归并的操作就是不断合并不断比较两个子序列中元素的大小合并为一个序列的过程。<br>假如你手上有两手牌(牌的数量不一定相等)，都已经按照由小到大排好。现在就是从两手牌中选择最小的打出去。依次选择，如果其中一首牌全部打完了，另一首牌就全部直接依次打出。打出的牌就是按照由小到大的顺序排列。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left,right)</span>:</span></span><br><span class="line">    i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> i &lt; len(left) <span class="keyword">and</span> j &lt; len(right):</span><br><span class="line">        <span class="keyword">if</span> left[i] &lt;= right[j]:</span><br><span class="line">            result.append(left[i])</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right[j])</span><br><span class="line">            j = j + <span class="number">1</span></span><br><span class="line">    result += left[i:]</span><br><span class="line">    result += right[j:]</span><br><span class="line">    <span class="comment">#print result</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p><p><strong>完整的实现：</strong><br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    length = len(arr)</span><br><span class="line">    <span class="keyword">if</span> length &lt;= <span class="number">1</span> <span class="keyword">or</span> arr == <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    num = length / <span class="number">2</span></span><br><span class="line">    left = mergeSort(arr[:num])</span><br><span class="line">    right = mergeSort(arr[num:])</span><br><span class="line">    <span class="comment">#print left,right</span></span><br><span class="line">    <span class="keyword">return</span> merge(left, right)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left,right)</span>:</span></span><br><span class="line">    i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> i &lt; len(left) <span class="keyword">and</span> j &lt; len(right):</span><br><span class="line">        <span class="keyword">if</span> left[i] &lt;= right[j]:</span><br><span class="line">            result.append(left[i])</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right[j])</span><br><span class="line">            j = j + <span class="number">1</span></span><br><span class="line">    result += left[i:]</span><br><span class="line">    result += right[j:]</span><br><span class="line">    <span class="comment">#print result</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p><p><strong>test</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*eg:</span><br><span class="line">    lists = [2, 9, 1, 3, 8, 4, 7, 6, 5,0]</span><br><span class="line">    mergeSort(lists)     </span><br><span class="line">*/</span><br><span class="line">result:</span><br><span class="line">    [2] [9]</span><br><span class="line">    [2, 9]</span><br><span class="line">    [3] [8]</span><br><span class="line">    [3, 8]</span><br><span class="line">    [1] [3, 8]</span><br><span class="line">    [1, 3, 8]</span><br><span class="line">    [2, 9] [1, 3, 8]</span><br><span class="line">    [1, 2, 3, 8, 9]</span><br><span class="line">    [4] [7]</span><br><span class="line">    [4, 7]</span><br><span class="line">    [5] [0]</span><br><span class="line">    [0, 5]</span><br><span class="line">    [6] [0, 5]</span><br><span class="line">    [0, 5, 6]</span><br><span class="line">    [4, 7] [0, 5, 6]</span><br><span class="line">    [0, 4, 5, 6, 7]</span><br><span class="line">    [1, 2, 3, 8, 9] [0, 4, 5, 6, 7]</span><br><span class="line">    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></pre></td></tr></table></figure></p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>由于中间归并时，left[i] &lt;= left[j]，相等时首选left，即不存在跳跃问题，算法稳定。归并排序需要，每一层比较的时间复杂度O(n),递归树层次是logn + 1，故总得时间复杂度为O(nlogn)。空间复杂度是O(n+logn)</p><h3 id="数组的逆序对"><a href="#数组的逆序对" class="headerlink" title="数组的逆序对"></a>数组的逆序对</h3><p>数组的逆序对，就是在数组中，前面数比它后面的数大就构成逆序对。[4, 3, 2, 5]逆序对有[4, 3]、[4, 2]、[3, 2]，共3对。<br>使用暴力算法，两个for循环嵌套可以解决，但是时间复杂度O(n^2)，太暴力了，不可取！！(鄙人曾经做过。。)<br>首先我们看看两组子序列是内部中构成逆序列[4,3]和[2, 5]，只有1对。如果我们把子序列都排好序（由小到大）。[3, 4]和[2, 5]。我们只需要统计[3, 4]中的元素是否大于序列[2, 5]中元素，只要大于就构成逆序对！！！而且前者某一个元素i大于后序列某一元素j，则我们可以直接知道前者中元素i后面的元素都与元素j构成逆序对（有小到大的序列）。<br>这样子统计完，就知道整个数组的逆序对的个数了。<br><strong>划分-&gt;归并排序-&gt;再划分-&gt;再归并排序。</strong><br>核心思想其实就是归并排序。唯一的区别就是在判断大小时统计有多少个前者小于后者。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    length = len(arr)</span><br><span class="line">    <span class="keyword">if</span> length &lt;= <span class="number">1</span> <span class="keyword">or</span> arr == <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    num  = length / <span class="number">2</span></span><br><span class="line">    left = mergeSort(arr[:num])</span><br><span class="line">    right = mergeSort(arr[num:])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> merge(left, right)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left, right)</span>:</span></span><br><span class="line">    i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> i &lt; len(left) <span class="keyword">and</span> j &lt; len(right):</span><br><span class="line">        <span class="keyword">if</span> left[i] &lt;= right[j]:</span><br><span class="line">            result.append(left[i])</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right[j])</span><br><span class="line">            <span class="keyword">global</span> count <span class="comment">#全局变量</span></span><br><span class="line">            count = count + len(left) - i</span><br><span class="line">            j = j + <span class="number">1</span></span><br><span class="line">    result += left[i:]</span><br><span class="line">    result += right[j:]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result     </span><br><span class="line">            </span><br><span class="line">count  = <span class="number">0</span></span><br><span class="line">lists = [<span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>,<span class="number">0</span>]</span><br><span class="line">mergeSort(lists)</span><br><span class="line"><span class="keyword">print</span> count <span class="comment"># 24</span></span><br></pre></td></tr></table></figure></p><p>空间换时间，用O(n)的空间换成时间复杂度O(nlogn)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;归并排序&quot;&gt;&lt;a href=&quot;#归并排序&quot; class=&quot;headerlink&quot; title=&quot;归并排序&quot;&gt;&lt;/a&gt;归并排序&lt;/h2&gt;&lt;p&gt;建立在归并操作上的一种有效的排序算法,该算法是采用分治法。以二路归并为例。&lt;br&gt;二路归并就是讲含有n个数据的序列看成是n个
      
    
    </summary>
    
      <category term="Algorithms" scheme="https://minenet.github.io/categories/Algorithms/"/>
    
    
  </entry>
  
  <entry>
    <title>堆排序</title>
    <link href="https://minenet.github.io/2016/08/22/heapSort.html"/>
    <id>https://minenet.github.io/2016/08/22/heapSort.html</id>
    <published>2016-08-21T16:01:03.000Z</published>
    <updated>2018-04-19T10:43:50.694Z</updated>
    
    <content type="html"><![CDATA[<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p><strong>思想</strong><br>首先来认识什么是堆，堆是一种数据结构，具有完全二叉树的性质。堆又分大顶堆和小顶堆。在数组arr[0, …n-1]中，对于某个结点i,<br>parent = (i-1) / 2<br>lchild = 2i + 1<br>rchild = 2i + 2<br>大顶堆：每个结点的值大于或等于其左右孩子结点值。<br>小顶堆：每个结点的值小于或等于其左右孩子结点值。<br>在堆排序中采用的是大顶堆排序。最大的结点在根结点。<br><strong>堆的调整</strong><br>如何让一个组数据保持大顶堆的性质呢？也就是调整一组数据使其保持和具有大顶堆得性质。<br>假设某个结点的左右孩子都是最大堆，但是该节点却不是最大堆。则需要在该节点arr[i]、arr[lchild]、和arr[rchild]中选择出一个最大值为arr[max]。如果最arr[i]最大则是最大堆，无需调整。如果不是，则需要交换arr[i]和arr[max]，交换后，可能孩子结点不是最大堆，则需要重新建立堆。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">adjustHeap</span><span class="params">(arr, i, length)</span>:</span></span><br><span class="line">    lchild = <span class="number">2</span>*i + <span class="number">1</span></span><br><span class="line">    rchild = <span class="number">2</span>*i + <span class="number">2</span></span><br><span class="line">    max = i</span><br><span class="line">    <span class="keyword">if</span> i &lt; length/<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">if</span> lchild &lt; length <span class="keyword">and</span> arr[lchild] &gt; arr[max]:</span><br><span class="line">            max = lchild</span><br><span class="line">        <span class="keyword">if</span> rchild &lt; length <span class="keyword">and</span> arr[rchild] &gt; arr[max]:</span><br><span class="line">            max = rchild</span><br><span class="line">        <span class="keyword">if</span> max <span class="keyword">is</span> <span class="keyword">not</span> i:</span><br><span class="line">            arr[max], arr[i] = arr[i], arr[max]</span><br><span class="line">            adjustHeap(arr, max, length)</span><br></pre></td></tr></table></figure><p>注意调用此函数的前提条件，i的左右孩子都是最大堆。<br><strong>建立堆</strong><br>为了保证堆得建立，反复调整最后得到完整的堆，我们只需要从最下面的非叶子结点开始调整，直到根结点成为最大的堆。<br>由二叉树的性质有，如果i&gt;1,则其双亲结点是小于等于i/2<br>由于数组下标从零开始，即n个结点则从n/2 -1，n/2 -2 …0。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildHeap</span><span class="params">(arr, length)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, length/<span class="number">2</span>)[::<span class="number">-1</span>]:</span><br><span class="line">        adjustHeap(arr, i, length)</span><br></pre></td></tr></table></figure></p><p><strong>堆排序</strong><br>为了进行排序，我们只需将排好序的堆中最大堆与未经排序的子序列最后一个交换。length为数组长度，heapSize为堆的大小，arr[0, length-1]为数组，arr[0, heapsize-1]为堆，arr[heapSize, length-1]为排好序的堆。</p><ul><li>令heapSize = length，建立完整的堆，bulidHeap(arr, heapSize)</li><li>i = length-1，交换arr[0]和arr[lenght-1]，heapSize–，i–</li><li>交换后，左后孩子仍为最大堆，但是结点不满足最大堆，则需要重新调整大小。adjustHeap(arr, 0, heapSize)</li><li>重复以上两步骤，直至排好序。  </li></ul><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    length = len(arr)</span><br><span class="line">    heapSize = length</span><br><span class="line">    buildHeap(arr, heapSize)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, length<span class="number">-1</span>)[::<span class="number">-1</span>]:</span><br><span class="line">        arr[<span class="number">0</span>], arr[i] = arr[i], arr[<span class="number">0</span>]</span><br><span class="line">        adjustHeap(arr, <span class="number">0</span>, heapSize<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><p><strong>完整程序</strong><br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">adjustHeap</span><span class="params">(arr, i, length)</span>:</span></span><br><span class="line">    lchild = <span class="number">2</span>*i + <span class="number">1</span></span><br><span class="line">    rchild = <span class="number">2</span>*i + <span class="number">2</span></span><br><span class="line">    max = i</span><br><span class="line">    <span class="keyword">if</span> i &lt; length/<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">if</span> lchild &lt; length <span class="keyword">and</span> arr[lchild] &gt; arr[max]:</span><br><span class="line">            max = lchild</span><br><span class="line">        <span class="keyword">if</span> rchild &lt; length <span class="keyword">and</span> arr[rchild] &gt; arr[max]:</span><br><span class="line">            max = rchild</span><br><span class="line">        <span class="keyword">if</span> max <span class="keyword">is</span> <span class="keyword">not</span> i:</span><br><span class="line">            arr[max], arr[i] = arr[i], arr[max]</span><br><span class="line">            adjustHeap(arr, max, length)</span><br><span class="line">            </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildHeap</span><span class="params">(arr, length)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, length/<span class="number">2</span>)[::<span class="number">-1</span>]:</span><br><span class="line">        adjustHeap(arr, i, length)</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    length = len(arr)</span><br><span class="line">    heapSize = length</span><br><span class="line">    buildHeap(arr, heapSize)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, length<span class="number">-1</span>)[::<span class="number">-1</span>]:</span><br><span class="line">        arr[<span class="number">0</span>], arr[i] = arr[i], arr[<span class="number">0</span>]</span><br><span class="line">        adjustHeap(arr, <span class="number">0</span>, heapSize<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure></p><p><strong>应用</strong><br>堆的时间主要消耗在堆的建立和调整上。对于每个非终端结点来说，只需要进行两次比较和互换，构建堆的时间复杂度为O(n)，由于完全二叉树的某个结点到根结点的距离为小于等于logi + 1，需要你时间logi，并且需要n-1次，故时间复杂度为O(nlogn)。总体时间复杂度为O(n) + O(nlogn),即O(nlogn).性能要比冒泡，选择、直接插入(时间复杂度O(n^2))要好。<br>空间复杂度上，只有一个交换暂存单元。交换和比较是跳跃式的，故堆排序不稳定。<br>不适合待排序列个数较少的情况。<br><strong>补充</strong><br>关于调整堆，可以换成非递归形式。</p><ul><li>对于某一个结点i，如果有孩子结点，它左孩子结点一定为2i+1，右孩子结点为2i+2，</li><li>调整一个非叶子结点arr[i]为最大堆，实质是调整n/2 -1,n/2-2…0为最大堆。</li></ul><ol><li>假设temp = arr[i]。</li><li>比较arr[2i+1]和arr[2i+2]的大小，记录最大一个孩子结点arr[j]。</li><li>比较temp 和arr[j]的大小，如果temp &gt; arr[j]该结点本来就是最大堆不用交换，结束循环。反之，将arr[j]赋给arr[i],同时将j赋给 i，这可能使得arr[j]不是最大堆，则重复步骤2和3，重新调整使其孩子结点满足最大堆。最后arr[i] = temp。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#非递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">adjustHeap</span><span class="params">(arr, i, length)</span>:</span></span><br><span class="line">    temp = arr[i]</span><br><span class="line">    j = <span class="number">2</span>*i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j &lt; length:   <span class="comment">#沿着较大的左右孩子结点筛选</span></span><br><span class="line">        <span class="keyword">if</span> j+<span class="number">1</span> &lt; length <span class="keyword">and</span> arr[j] &lt; arr[j+<span class="number">1</span>]:</span><br><span class="line">            j = j + <span class="number">1</span> <span class="comment">#记录孩子结点中较大的标号</span></span><br><span class="line">        <span class="keyword">if</span> temp &gt; arr[j]:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        arr[i] = arr[j]</span><br><span class="line">        i = j</span><br><span class="line">        j = <span class="number">2</span>*j + <span class="number">1</span></span><br><span class="line">    arr[i] = temp</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    length = len(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, length/<span class="number">2</span>)[::<span class="number">-1</span>]:</span><br><span class="line">        adjustHeap(arr, i, length)<span class="comment">#建立堆</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,length)[::<span class="number">-1</span>]:</span><br><span class="line">        arr[i], arr[<span class="number">0</span>] = arr[<span class="number">0</span>], arr[i]</span><br><span class="line">        adjustHeap(arr, <span class="number">0</span>, j<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;堆排序&quot;&gt;&lt;a href=&quot;#堆排序&quot; class=&quot;headerlink&quot; title=&quot;堆排序&quot;&gt;&lt;/a&gt;堆排序&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;思想&lt;/strong&gt;&lt;br&gt;首先来认识什么是堆，堆是一种数据结构，具有完全二叉树的性质。堆又分大顶堆和小顶堆。在数
      
    
    </summary>
    
      <category term="Algorithms" scheme="https://minenet.github.io/categories/Algorithms/"/>
    
    
  </entry>
  
  <entry>
    <title>冒泡&amp;选择排序</title>
    <link href="https://minenet.github.io/2016/08/21/bubbleSort-and-selectSort.html"/>
    <id>https://minenet.github.io/2016/08/21/bubbleSort-and-selectSort.html</id>
    <published>2016-08-20T17:41:14.000Z</published>
    <updated>2018-04-19T10:43:50.694Z</updated>
    
    <content type="html"><![CDATA[<h2 id="冒泡法排序"><a href="#冒泡法排序" class="headerlink" title="冒泡法排序"></a>冒泡法排序</h2><p><strong>思想</strong><br>一次比较两个相邻的数据。将待排序的元素看做气泡，较小的元素比较轻，就会上浮。每次操作就是比较两个相邻元素的位置是否正确，不正确时，轻的元素（较小的）应该上浮，即交换它们的位置。第一比较，最轻的元素一定浮在最上面了。第二次比较得出的第二轻的元素，第i遍比较时，由于前面的i-1遍比较已经得出了排序，就不必要比较i上面的元素。<br><strong>算法实现</strong>  </p><pre><code class="python"><span class="function"><span class="keyword">def</span> <span class="title">bubbleSort</span><span class="params">(arr)</span>:</span>    length = len(arr)    <span class="keyword">for</span> i <span class="keyword">in</span> range(length):        <span class="keyword">for</span> j <span class="keyword">in</span>  range(length<span class="number">-1</span>, i, <span class="number">-1</span>):            <span class="keyword">if</span> arr[j<span class="number">-1</span>] &gt; arr[j]:                arr[j<span class="number">-1</span>], arr[j] = arr[j], arr[j<span class="number">-1</span>]        <span class="comment"># print arr</span>    <span class="keyword">return</span> arr</code></pre><p>上面是传统的冒泡法，当我们比较[2, 1, ,3, 4, 5, 6, 7, 8, 9],按照上面的算法，我们需要比较9遍。其实我们只需要进行一遍就好，第一遍就交换了2和1，其实后面就不用比较了。因此设置标识，优化算法，可以避免已经有序无意义的排序。<br><strong>算法优化</strong>  </p><pre><code class="python"><span class="function"><span class="keyword">def</span> <span class="title">bubbleSort</span><span class="params">(arr)</span>:</span>    length = len(arr)    flag = <span class="keyword">True</span>    <span class="keyword">for</span> i <span class="keyword">in</span> range(length):        flag = <span class="keyword">False</span>        <span class="keyword">for</span> j <span class="keyword">in</span>  range(length<span class="number">-1</span>, i, <span class="number">-1</span>):            <span class="keyword">if</span> arr[j<span class="number">-1</span>] &gt; arr[j]:                arr[j<span class="number">-1</span>], arr[j] = arr[j], arr[j<span class="number">-1</span>]                flag = <span class="keyword">True</span>        <span class="keyword">if</span> flag <span class="keyword">is</span> <span class="keyword">False</span>: <span class="comment">#发现某一遍比较，没有一次交换就说明有序，退出循环。</span>            <span class="keyword">break</span>    <span class="comment">#print arr</span>    <span class="keyword">return</span> arr</code></pre><p><strong>应用</strong><br>时间复杂度为O（n^2），稳定。</p><h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><p><strong>思想</strong><br>每次从未排序得元素中找出最小的，将其添加到已经排好序的元素中。第一趟从n个元素中选择最小的与第一个元素交换，第二趟从n-1个元素中选择最小的与第二个元素交换。<br><strong>算法实现</strong>  </p><pre><code class="python"><span class="function"><span class="keyword">def</span> <span class="title">selectSort</span><span class="params">(arr)</span>:</span>    length = len(arr)    <span class="keyword">for</span> i <span class="keyword">in</span> range(length):        min = i        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, length):            <span class="keyword">if</span> arr[i] &gt; arr[j]:                min = j        <span class="keyword">if</span> min <span class="keyword">is</span> <span class="keyword">not</span> i:            arr[min], arr[i] = arr[i], arr[min]        <span class="comment">#print arr</span>    <span class="keyword">return</span> arr</code></pre><p><strong>应用</strong><br>时间复杂度为O(n^2),算法不稳定。lists = [9, 7, 3, 9, 1]时，第一次9和1交换，两个9的相对前后序列就被打乱了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;冒泡法排序&quot;&gt;&lt;a href=&quot;#冒泡法排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡法排序&quot;&gt;&lt;/a&gt;冒泡法排序&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;思想&lt;/strong&gt;&lt;br&gt;一次比较两个相邻的数据。将待排序的元素看做气泡，较小的元素比较轻，就会
      
    
    </summary>
    
      <category term="Algorithms" scheme="https://minenet.github.io/categories/Algorithms/"/>
    
    
  </entry>
  
  <entry>
    <title>插入&amp;希尔排序</title>
    <link href="https://minenet.github.io/2016/08/21/insertSort-and-shellSort.html"/>
    <id>https://minenet.github.io/2016/08/21/insertSort-and-shellSort.html</id>
    <published>2016-08-20T17:34:02.000Z</published>
    <updated>2018-04-19T10:43:50.694Z</updated>
    
    <content type="html"><![CDATA[<h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><p><strong>思想</strong><br>对于一个数据插入到一个已经排好序的数据中，得到一个新的数据序列。就如同打牌时接牌，右手摸起来的牌插入到左手中，按照由小到大的顺序排列。<br><strong>算法实现</strong><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    length = len(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, length):</span><br><span class="line">        key  = arr[i]</span><br><span class="line">        j = j <span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> arr[j] &gt; key:</span><br><span class="line">            arr[j+<span class="number">1</span>] = arr[j]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        arr[j+<span class="number">1</span>] = key    </span><br><span class="line">        <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure></p><p><strong>应用</strong><br>适用于数据量少的排序，时间复杂度为 O(n^2), 稳定。 </p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序是基于插入排序的改进，虽然插入排序的线性排序的效率高，但由于每次插入排序只能移动一位，所以效率任然是低效的。<br><strong>思想</strong><br>设置一定的步长，以一定的步长对数据进行直接插入排序，直至步长为1，进行直接插入排序。<br><strong>算法实现</strong><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shellSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    length = len(arr)</span><br><span class="line">    gap = length / <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(gap, length):</span><br><span class="line">            key = arr[i]</span><br><span class="line">            j = i</span><br><span class="line">            <span class="keyword">while</span> j &gt;= gap <span class="keyword">and</span> arr[j-gap] &gt; key:</span><br><span class="line">                arr[j] = arr[j- gap]</span><br><span class="line">                j = j - gap</span><br><span class="line">            arr[j] = key</span><br><span class="line">        gap = gap / <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lists = [<span class="number">1</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>]</span><br><span class="line">第一次步长是：<span class="number">4</span></span><br><span class="line"><span class="number">1</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span></span><br><span class="line"><span class="number">4</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span></span><br><span class="line">对上面每一列排序得：</span><br><span class="line"><span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span></span><br><span class="line"><span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span></span><br><span class="line">lists = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>]</span><br><span class="line">第二次步长是：<span class="number">2</span></span><br><span class="line"><span class="number">1</span>, <span class="number">3</span></span><br><span class="line"><span class="number">3</span>, <span class="number">2</span></span><br><span class="line"><span class="number">4</span>, <span class="number">7</span></span><br><span class="line"><span class="number">6</span>, <span class="number">5</span></span><br><span class="line">对上面每一列排序得：</span><br><span class="line"><span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="number">3</span>, <span class="number">3</span></span><br><span class="line"><span class="number">4</span>, <span class="number">5</span></span><br><span class="line"><span class="number">6</span>, <span class="number">7</span></span><br><span class="line">lists = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">第三次步长是：<span class="number">1</span></span><br><span class="line">lists = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br></pre></td></tr></table></figure><p><strong>应用</strong><br>时间复杂度O(nlog^2 n)，不稳定。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;直接插入排序&quot;&gt;&lt;a href=&quot;#直接插入排序&quot; class=&quot;headerlink&quot; title=&quot;直接插入排序&quot;&gt;&lt;/a&gt;直接插入排序&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;思想&lt;/strong&gt;&lt;br&gt;对于一个数据插入到一个已经排好序的数据中，得到一个新的数据序列
      
    
    </summary>
    
      <category term="Algorithms" scheme="https://minenet.github.io/categories/Algorithms/"/>
    
    
  </entry>
  
  <entry>
    <title>解决CNAME和MX记录冲突</title>
    <link href="https://minenet.github.io/2016/08/17/cname-and-mx-conflict.html"/>
    <id>https://minenet.github.io/2016/08/17/cname-and-mx-conflict.html</id>
    <published>2016-08-17T13:16:48.000Z</published>
    <updated>2018-04-19T10:43:50.693Z</updated>
    
    <content type="html"><![CDATA[<p>kloudsec由于公司资金原因关闭，加上证书的过期，维持不到半年的小绿锁突然消失了，第三方的转发缘故，网站也不能访问，需要重新设置解析。首先让网站能访问起来。</p><h3 id="设置解析"><a href="#设置解析" class="headerlink" title="设置解析"></a>设置解析</h3><p>域名购买和备案都在阿里云，在控制台重新设置解析时，又遇见问题，MX的记录和CNAME冲突（申请过免费的企业邮箱），免费的企业邮箱虽然没怎么用，但是还是想保留着。之前https属于转发，访问站点时，我的理解是先访问Kloudsec，然后Kloudsec的服务器访问github io,把消息反馈给服务器，然后加密处理呈现给用户。是一种伪证书，因为github pages是不支持上传个人证书的，尽管现在github pages全面支持https了，那只是针对<code>username.github.io</code>，如果是使用的是个性域名，则不能安全访问。由于博客属于静态页面，为了满足一点逼格，就利用免费的第三方（学生党，穷！）转发，选择cloudflare。<br>回到问题的，如何解决冲突，搜了一下都好像没有一个比较明确的答案，很多答案是选择了第三方的DNS供应商。比如<a href="https://www.dnspod.cn/" target="_blank" rel="noopener">DNSpod</a>，可以共存，但是会提示你，邮件可能会丢失的风险，也就是说可能发的出去，但是收不到的情况。其实这是国际惯例，在RFC解析协议中，CNAME记录的优先级高于MX记录的优先级，且不能共存。为了解决这种风险，所采用的方式就是，先对WWW做CNAME记录，然后对@做A记录指向github page的ip，相当于做了一次跳转。<br><img src="/image/record.png" class="img-center"></p><p>然后就是等待DNS的刷新，稍后就可以访问了。</p><h3 id="cloudflare的申请"><a href="#cloudflare的申请" class="headerlink" title="cloudflare的申请"></a>cloudflare的申请</h3><ul><li><a href="https://www.cloudflare.com" target="_blank" rel="noopener">cloudflare</a>官网直接申请个账号。</li><li>添加域名，然后scan。</li><li>在域名供应商或第三方的DNS供应商那里修改成由clouudflare提供的DNS。</li><li>等待吧。。。（需要一段时间），就会出现久违的小绿锁。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;kloudsec由于公司资金原因关闭，加上证书的过期，维持不到半年的小绿锁突然消失了，第三方的转发缘故，网站也不能访问，需要重新设置解析。首先让网站能访问起来。&lt;/p&gt;
&lt;h3 id=&quot;设置解析&quot;&gt;&lt;a href=&quot;#设置解析&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="Blog" scheme="https://minenet.github.io/categories/Blog/"/>
    
    
      <category term="git" scheme="https://minenet.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>分层聚类算法</title>
    <link href="https://minenet.github.io/2016/06/30/Hierarchical-clustering.html"/>
    <id>https://minenet.github.io/2016/06/30/Hierarchical-clustering.html</id>
    <published>2016-06-30T14:07:31.000Z</published>
    <updated>2018-04-19T10:43:50.693Z</updated>
    
    <content type="html"><![CDATA[<h3 id="分层聚类"><a href="#分层聚类" class="headerlink" title="分层聚类"></a>分层聚类</h3><p>分层聚类，就是以一组原始数据中的数据项开始，计算它们的相关度，寻找最相关的两个聚在一起形成新的聚类。新生成的聚类中包含的数据等于两个旧聚类的数据平均值，再次计算数（包含聚类后）相关度，寻找最相关的，进行聚类。一直循环重复下去，直到是剩下一个聚类为止。例如：<br>对于原始数据[A, B, C, D, E]进行分层聚类。  </p><ol><li>寻找最相关的两个，比如AB聚在一起。第一次聚类后[AB, C, D, E]，其中AB为A和B数据的平均值.</li><li>再次互相计算相关度，发现C和D最接近，则[AB, CD, E],只剩下E.</li><li>再次计算相关度E与AB最接近，则[ABE, CD]，最后剩下的就是合并将两个聚类合在一起[ABCDE]结束。<br>核心算法的实现：<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> *@discription:Hierarchical Clustering</span><br><span class="line"> *@<span class="keyword">return</span> clust[<span class="number">0</span>]</span><br><span class="line"> */</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">bicluster</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, vec, left=None, right=None, distance=<span class="number">0.0</span>, id=None)</span>:</span></span><br><span class="line">    self.left = left</span><br><span class="line">    self.right = right</span><br><span class="line">    self.vec = vec</span><br><span class="line">    self.id = id</span><br><span class="line">    self.distance = distance</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hcluster</span><span class="params">(rows, ditance=person)</span>:</span></span><br><span class="line">        distance = &#123;&#125;</span><br><span class="line">        currentclustid = <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        cluste = [biclutser(row[i], id=i) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(rows))]</span><br><span class="line">        <span class="keyword">while</span> len(cluste) &gt; <span class="number">1</span>:</span><br><span class="line">            lowestpair = (<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">            closest = distance(clust[<span class="number">0</span>].vec, clust[<span class="number">1</span>].vec)</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(clust)):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(clust)):</span><br><span class="line">                    <span class="keyword">if</span>(clust[i].id, clust[j].id) <span class="keyword">not</span> ditances:</span><br><span class="line">                        distance[(clust[i].id, clust[j].id)] = distance(clust[i].vec, clust[j].vec)</span><br><span class="line">            </span><br><span class="line">                    d = distance[(clust[i].id, clust[j].id)]</span><br><span class="line">                    <span class="keyword">if</span> d &lt; closest:</span><br><span class="line">                        closest = d</span><br><span class="line">                        lowestpair =(i, j)</span><br><span class="line">            mergevec = [(clust[lowestpair[<span class="number">0</span>]].vec[i] + clust[lowest[<span class="number">1</span>]].vec[i]) / <span class="number">2.0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(clust[<span class="number">0</span>].vec))]</span><br><span class="line">        </span><br><span class="line">            newcluster = bicluster(mergevec, left=clust[lowestpair[<span class="number">0</span>]], right=clust[lowestpair[<span class="number">1</span>]], distacne=closest, id=currentclustid)</span><br><span class="line">        </span><br><span class="line">            currentclustid -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">del</span> clust[lowestpair[<span class="number">1</span>]]</span><br><span class="line">            <span class="keyword">del</span> clust[lowestpair[<span class="number">0</span>]]</span><br><span class="line">            clust.append(newcluster)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> clust[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;分层聚类&quot;&gt;&lt;a href=&quot;#分层聚类&quot; class=&quot;headerlink&quot; title=&quot;分层聚类&quot;&gt;&lt;/a&gt;分层聚类&lt;/h3&gt;&lt;p&gt;分层聚类，就是以一组原始数据中的数据项开始，计算它们的相关度，寻找最相关的两个聚在一起形成新的聚类。新生成的聚类中包含的数据
      
    
    </summary>
    
      <category term="Algorithms" scheme="https://minenet.github.io/categories/Algorithms/"/>
    
    
  </entry>
  
  <entry>
    <title>《集体智慧编程》学习笔记（1）</title>
    <link href="https://minenet.github.io/2016/06/21/Programming-Collection-Intelligence-1.html"/>
    <id>https://minenet.github.io/2016/06/21/Programming-Collection-Intelligence-1.html</id>
    <published>2016-06-21T06:36:20.000Z</published>
    <updated>2018-04-19T10:43:50.693Z</updated>
    
    <content type="html"><![CDATA[<p>最近一直在学习集体智慧编程，第二章开始就学习推荐。用了简单的例子对常见的推荐做了简单的实践应用。上一篇博客中写到了几种常见推荐算法的优劣。现在主要记录几种相似度计算以及部分课后习题的练习。</p><h3 id="欧几里德距离"><a href="#欧几里德距离" class="headerlink" title="欧几里德距离"></a>欧几里德距离</h3><p>计算多维空间的两点的距离，通过距离的远近来表示相似度。<br>$ (p_1,p_2,p_3,\cdots) $和$ (q_1,q_2,q_3,\cdots) $两个点的欧几里得距离为：</p><p>$$ \sqrt{\sum_{i=1}^{n}(p_i-q_i)^2}= \sqrt{(p_1-q_1)^{2} + (p_2-q_2)^2 + \cdots +(p_n-q_n)^2} \tag{1}$$</p><p>上面式子中就是求两个点的欧几里德距离。Python代码实现：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">euclidean</span><span class="params">(p,q)</span>:</span></span><br><span class="line">    sum = <span class="number">0.0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(P)):</span><br><span class="line">    sum += (p[i] - q[i])**<span class="number">2</span></span><br><span class="line"><span class="keyword">return</span> sum**<span class="number">0.5</span></span><br></pre></td></tr></table></figure></p><h3 id="皮尔逊相关系数"><a href="#皮尔逊相关系数" class="headerlink" title="皮尔逊相关系数"></a>皮尔逊相关系数</h3><p>两个变量之间的相关程度，通过这个相关程度表示相似度。<br>$$ r = \frac{\sum{XY}-\frac{\sum{X}\sum{Y}}{N}} {\sqrt{(\sum{X}^2-\frac{(\sum{X})^2}{N})(\sum{Y}^2-\frac{(\sum{Y})^2}{N})}}  \tag{2}$$</p><p>皮尔逊相关系数python实现：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pearson</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    n = len(x)</span><br><span class="line"></span><br><span class="line">    sum_x = sum(float(i) <span class="keyword">for</span> i <span class="keyword">in</span> x)</span><br><span class="line">    sum_y = sum(float(i) <span class="keyword">for</span> i <span class="keyword">in</span> y)</span><br><span class="line">    </span><br><span class="line">    sum_x2 = sum(i**<span class="number">2.0</span> <span class="keyword">for</span> i <span class="keyword">in</span> x)</span><br><span class="line">    sum_y2 = sum(i**<span class="number">2.0</span> <span class="keyword">for</span> i <span class="keyword">in</span> y)</span><br><span class="line">    </span><br><span class="line">    sum_xy = sum(x[i]*y[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(n))</span><br><span class="line">    </span><br><span class="line">    den = ((sum_x2 - (sum_x**<span class="number">2.0</span>)/n) * (sum_y2 - (sum_y**<span class="number">2.0</span>)/n ))**<span class="number">0.5</span></span><br><span class="line">    <span class="keyword">if</span> den == <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> (sum_xy-(sum_x * sum_y)/n) / den</span><br></pre></td></tr></table></figure></p><p>注：1表示变量完全相关，0表示无关，-1表示完全负相关。</p><p>如何选择相似度的计算，就需要根据场合选择合适的系数来计算。比如item特别少时，欧几里德距离就出现偏差过大。 </p><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>主要解答第五题。<br>首先去官网<a href="http://www.last.fm" target="_blank" rel="noopener">LAST.FM</a>申请API的账户。你将会获得API_KEY等相关秘钥。、<br>与Python想关的API也可以在官网获得。代码托管在github上<a href="https://github.com/pylast/pylast" target="_blank" rel="noopener">pylast</a>。</p><p>可能由于网站的改版等原因，有些函数返回的结果为空，有点蛋疼。所做的推荐也比较简单，大致思路：</p><ol><li>根据你想要推荐的tag，首先找出网站所有的排行榜靠前的标签（tags）。</li><li>根据这些热门标签找出被打出行管tag的音乐专辑。</li><li>对于计算Tanimoto相似度，得出与想要推荐tag相关的tag（根据tag找专辑，找歌曲）。</li></ol><p>贴代码： </p><pre><code class="py"><span class="keyword">import</span> pylast<span class="string">'''</span><span class="string">This a test for last.fm API, you can get functions by help(pylast).</span><span class="string">author: minenet</span><span class="string">'''</span><span class="comment"># you must get a account from http://www.last.fm/api, API_KEY and API_SECRET</span>API_KEY = <span class="string">'your API_KEY'</span> API_SECRET = <span class="string">'your API_SECRET'</span>username = <span class="string">'your username'</span>password_hash = pylast.md5(<span class="string">'your password'</span>)network = pylast.LastFMNetwork(    api_key = API_KEY,     api_secret = API_SECRET,     username = username,    password_hash = password_hash)<span class="function"><span class="keyword">def</span> <span class="title">albumsList</span><span class="params">(tag=<span class="string">''</span>)</span>:</span>    albums_list = {}    tags = network.get_top_tags()    tagList = []    <span class="keyword">for</span> tg <span class="keyword">in</span> tags:        tg = str(tg)        tag_start = tg.index(<span class="string">'Tag'</span>) + <span class="number">6</span>        tag_end = tg.index(<span class="string">','</span>) - <span class="number">1</span>        tagList.append(tg[tag_start:tag_end])    <span class="keyword">if</span> tag <span class="keyword">not</span> <span class="keyword">in</span> tagList:        tagList.append(tag)    <span class="keyword">for</span> tagItem <span class="keyword">in</span> tagList:            tag = network.get_tag(tagItem)        albums_list[tagItem] = {}        <span class="keyword">for</span> album <span class="keyword">in</span> tag.get_top_albums():            album = str(album)            album_start = album.index(<span class="string">'Album'</span>) + <span class="number">8</span>            album_end = album.index(<span class="string">','</span>) - <span class="number">1</span>            album = album[album_start:album_end]            albums_list[tagItem][album] = <span class="number">1.0</span>            <span class="keyword">return</span> albums_list<span class="function"><span class="keyword">def</span> <span class="title">recommendations</span><span class="params">(tag=<span class="string">''</span>, n=<span class="number">5</span>)</span>:</span>    albums_list = albumsList(tag)    recommendation = []    <span class="keyword">for</span> item <span class="keyword">in</span> albums_list:        <span class="keyword">if</span> item != tag:            scores = sim_tanimoto(albums_list, tag, item)            recommendation.append((scores, item))    recommendation.sort()    recommendation.reverse()    <span class="keyword">return</span> recommendation[<span class="number">0</span>:n]<span class="function"><span class="keyword">def</span> <span class="title">sim_tanimoto</span><span class="params">(prefs,tag,item)</span>:</span>    cossElement = [sim <span class="keyword">for</span> sim <span class="keyword">in</span> prefs[item] <span class="keyword">if</span> sim <span class="keyword">in</span> prefs[tag]]    <span class="keyword">return</span> float(len(cossElement)) / (len(prefs[item])+ len(prefs[tag]) - len(cossElement))<span class="keyword">print</span> recommendations(<span class="string">'rock'</span>)<span class="string">'''</span><span class="string">print example:</span><span class="string">[(0.07407407407407407, 'hard rock'),</span><span class="string"> (0.06976744186046512, 'classic rock'), </span><span class="string"> (0.06557377049180328, 'alternative rock'), </span><span class="string"> (0.05660377358490566, 'pop'), </span><span class="string"> (0.05084745762711865, 'british')]</span><span class="string"></span><span class="string">'''</span><span class="keyword">if</span> you want get more help, you can use commmand help(pylast) <span class="keyword">in</span> python command line.</code></pre><p>相似度计算也可以选择其他的，代码中使用了Tanimoto。<br>$$ T = \frac{N_c}{N_a + N_b - N_c} \tag{3}$$</p><p>其中对于集合A和B，$ N_a,N_b $分别是A,B元素的个数，$ N_c = A \cap B $ </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近一直在学习集体智慧编程，第二章开始就学习推荐。用了简单的例子对常见的推荐做了简单的实践应用。上一篇博客中写到了几种常见推荐算法的优劣。现在主要记录几种相似度计算以及部分课后习题的练习。&lt;/p&gt;
&lt;h3 id=&quot;欧几里德距离&quot;&gt;&lt;a href=&quot;#欧几里德距离&quot; clas
      
    
    </summary>
    
      <category term="Machine Learning" scheme="https://minenet.github.io/categories/Machine-Learning/"/>
    
    
  </entry>
  
  <entry>
    <title>推荐算法的特点</title>
    <link href="https://minenet.github.io/2016/06/20/different-recommendations.html"/>
    <id>https://minenet.github.io/2016/06/20/different-recommendations.html</id>
    <published>2016-06-20T07:00:43.000Z</published>
    <updated>2018-04-19T10:43:50.693Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基于内容-CB-的推荐"><a href="#基于内容-CB-的推荐" class="headerlink" title="基于内容(CB)的推荐"></a>基于内容(CB)的推荐</h2><p>简单的一句话说，比如你在京东买东西，京东会根据你之前的购买或浏览的商品，推荐相似的商品。<br>大致步骤：  </p><ol><li>首先找出能代表item的特征，也就是item的content。</li><li>建立user的item特征数据，建立user喜好特征，也就是喜欢哪些，不喜欢哪些。</li><li>候选item特征和用户的喜好特征比较，推荐相似度最大的一组item。  </li></ol><p>主要是需要对item的特征建立。</p><h2 id="基于协同过滤-CF-的推荐"><a href="#基于协同过滤-CF-的推荐" class="headerlink" title="基于协同过滤(CF)的推荐"></a>基于协同过滤(CF)的推荐</h2><p>协同过滤的推荐主要有两种：ItemCF与UserCF</p><h3 id="基于物品-itemCF-的协同过滤"><a href="#基于物品-itemCF-的协同过滤" class="headerlink" title="基于物品(itemCF)的协同过滤"></a>基于物品(itemCF)的协同过滤</h3><p>大致步骤：</p><ol><li>计算物品的相似物品。</li><li>根据用户对物品的行为(评价,打分)和物品的相似度生成推荐列表。  </li></ol><h3 id="基于用户-UserCF-的协同过滤"><a href="#基于用户-UserCF-的协同过滤" class="headerlink" title="基于用户(UserCF)的协同过滤"></a>基于用户(UserCF)的协同过滤</h3><p>大致步骤：</p><ol><li>找出与用户相似的用户集合。</li><li>根据集合中用户喜好物品，找出待推荐用户没有出现的喜好物品形成推荐列表。</li></ol><h2 id="三者区别"><a href="#三者区别" class="headerlink" title="三者区别"></a>三者区别</h2><p><strong>基于内容(CB)  </strong><br>优点: </p><ol><li>推荐之间的用户独立，一个用户与其他用户无关。对于被网上刷评论的商品对推荐没有影响。</li><li>推荐理由明显，item的特征适合用户的品味。</li><li>新的item一出来，就可以推荐给用户。（协同过滤就不可以，必须依靠用户的打分评价行为）  </li><li>没有冷启动问题。  </li></ol><p>缺点： </p><ol><li>有些item的特征属性抽取困难，比如电影。</li><li>难以发掘用户潜在兴趣，原因只是针对过去喜欢的东西推荐相似的东西，但是一个人的兴趣只能不仅仅就一类东西。</li><li>新用户就无法推荐了，因为没有喜好历史。</li></ol><p><strong>基于协同过滤(CF)</strong><br>优点：</p><ol><li>能够过滤难以进行机器自动内容分析的信息，如艺术品，音乐等。</li><li>能够发掘用户的潜在兴趣。</li><li>过滤掉一些复杂、难以表述的概念。</li></ol><p>缺点：</p><ol><li>不能实时推荐，必须有用户行为后(最初评价问题)。</li><li>用户对商品的评价非常稀疏，这样基于用户的评价所得到的用户间的相似性可能不准确（即稀疏性问题）</li><li>冷启动问题。</li></ol><p><strong>UserCF算法的特点是：</strong>  </p><ol><li>用户较少的场合，否则用户相似度矩阵计算代价很大。</li><li>适合时效性较强，用户个性化兴趣不太明显的领域。</li><li>用户有新行为，不一定造成推荐结果的立即变化。</li><li>对新用户不友好，对新物品友好，因为用户相似度矩阵需要离线计算.</li><li>很难提供令用户信服的推荐解释。</li></ol><p><strong>对应地，ItemCF算法的特点：</strong>  </p><ol><li>适用于物品数明显小于用户数的场合，否则物品相似度矩阵计算代价很大。</li><li>适合长尾物品丰富，用户个性化需求强的领域。</li><li>用户有新行为，一定导致推荐结果的实时变化。</li><li>对新用户友好，对新物品不友好，因为物品相似度矩阵需要离线计算。</li><li>用用户历史行为做推荐解释，比较令用户信服。</li></ol><p>和UserCF算法相比，ItemCF算法的离线实验结果要差一些，不过这是在两者优化前的结果，实际优化后性能是接近的。原始ItemCF算法的覆盖率和新颖度不高的原因可以归结为哈利波特问题，也就是热门物品和其他物品的相似度都很高，这个问题一个办法是惩罚热门物品，同时可能还需要引入物品的内容数据来修正。</p><p>其他推荐的优缺点：<br><img src="/image/recommendations.png" class="img-center"></p><hr><p>参考文献：  </p><p><a href="http://www.yeolar.com/note/2013/10/03/recommend-system/#id22" target="_blank" rel="noopener">《推荐系统实践》笔记</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基于内容-CB-的推荐&quot;&gt;&lt;a href=&quot;#基于内容-CB-的推荐&quot; class=&quot;headerlink&quot; title=&quot;基于内容(CB)的推荐&quot;&gt;&lt;/a&gt;基于内容(CB)的推荐&lt;/h2&gt;&lt;p&gt;简单的一句话说，比如你在京东买东西，京东会根据你之前的购买或浏览的商
      
    
    </summary>
    
      <category term="Machine Learning" scheme="https://minenet.github.io/categories/Machine-Learning/"/>
    
    
  </entry>
  
  <entry>
    <title>Win7下安装MongoDB</title>
    <link href="https://minenet.github.io/2016/05/22/install-MongoDB-in-win7-os-x64.html"/>
    <id>https://minenet.github.io/2016/05/22/install-MongoDB-in-win7-os-x64.html</id>
    <published>2016-05-21T17:06:41.000Z</published>
    <updated>2018-04-19T10:43:50.693Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h1><p>OS：win7 os x64<br>MongoDB version : <a href="http://www.mongodb.org/downloads" target="_blank" rel="noopener">mongodb-win32-x86_64-2008plus-ssl-3.2.6-signed.msi</a>  </p><h1 id="Install-and-create-DB"><a href="#Install-and-create-DB" class="headerlink" title="Install and create DB"></a>Install and create DB</h1><p>安装直接点击<code>next</code> 即可，我选择安装的路径为<code>E:\mongodb</code>。创建数据库存储路径目录<code>F</code>盘。    </p><pre><code class="cmd"><span class="built_in">mkdir</span> data<span class="built_in">cd</span> data<span class="built_in">mkdir</span> db<span class="built_in">cd</span> db</code></pre><p>创建存储路径为<code>f:\data\db</code>。当然可以直接在对应目录手动创建。<br>启动MongoDB服务器，需要进入到MongoDB安装路径的<code>bin</code>下。我的是<code>e:\mongodb\bin</code>    </p><pre><code class="cmd">mongod.exe --dbpath f:\data\db</code></pre><p>执行成功后可以看到一个waiting for connections on port 27017。就说明成功了直接访问localhost:27017,可以看到如下  </p><pre><code class="cmd">It looks like you are trying to access MongoDB over HTTP on the native driver port.</code></pre><p>但是，这样子每次进入需要进入到安装目录启动MongoDB，太麻烦了，可以直接把MongoDB当做系统的服务运行即可，我们顺便可以写两个小脚本运行，开启和关闭。<br>首次我们在E:\mongodb下新建logs文件夹，并随后在logs新建文件mongodb.log,即e:\mongodb\logs\mongodb.log<br>还是进入到<code>bin</code>目录。   </p><pre><code class="cmd">mongod.exe --logpath e:\mongodb\logs\mongodb.log --logappend --dbpath f:\data\db --serviceName MongoDB --install  # 配置成服务<span class="built_in">net</span> <span class="built_in">start</span> MongoDB # 启动</code></pre><p><img src="/image/installMongDB_1.png" class="img-center"><br>cmd执行<code>services.msc</code>可以看到。<br><img src="/image/installMongoDB_2.png" class="img-center"></p><h1 id="MongoDB-mange"><a href="#MongoDB-mange" class="headerlink" title="MongoDB mange"></a>MongoDB mange</h1><p>首先开启MongoDB<code>net start MongoDB</code><br>cmd中进入到<code>e:\mongodb\bin</code>  </p><pre><code class="cmd">mongo.exe<span class="number">1</span>+<span class="number">1</span>     # <span class="number">2</span>db      # test 默认连接test数据库db.runoob.insert({x:<span class="number">10</span>})      # WriteResult({ "nInserted" : <span class="number">1</span> }) 数字 <span class="number">10</span> 插入到 runoob 集合的 x 字段中db.runoob.<span class="built_in">find</span>()     # { "_id" : ObjectId("<span class="number">5604</span>ff74a274a611b0c990aa"), "x" : <span class="number">10</span> } 查找</code></pre><p><img src="/image/installMongoDB_3.png" class="img-center"></p><h1 id="Start-amp-Stop"><a href="#Start-amp-Stop" class="headerlink" title="Start &amp; Stop"></a>Start &amp; Stop</h1><p>新建两个txt文件，分别命名为startMongoDB和stopMongoDB，里面分别写入</p><pre><code class="cmd"><span class="built_in">net</span> <span class="built_in">start</span> MongoDB</code></pre><pre><code class="cmd"><span class="built_in">net</span> stop MongoDB</code></pre><p>保存后，修改txt文件后缀名为<code>bat</code>成为批处理文件，每次直接双击就行（有的需要在‘管理员身份’运行），自由进行MongoDB开启和关闭。<br>开始玩耍MongoDB吧！<br>（tips：推荐一本MongoDB入门实践书籍<a href="https://book.douban.com/subject/26333934/" target="_blank" rel="noopener">大数据存储MongoDB实战指南</a> 老乡威哥的书籍，支持！）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Environment&quot;&gt;&lt;a href=&quot;#Environment&quot; class=&quot;headerlink&quot; title=&quot;Environment&quot;&gt;&lt;/a&gt;Environment&lt;/h1&gt;&lt;p&gt;OS：win7 os x64&lt;br&gt;MongoDB version 
      
    
    </summary>
    
      <category term="Database" scheme="https://minenet.github.io/categories/Database/"/>
    
    
      <category term="MongoDB" scheme="https://minenet.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu14.04安装JDK+Eclipse+Pydev</title>
    <link href="https://minenet.github.io/2016/05/19/install-jdk-eclipse-pydev-in-ubuntu14-04.html"/>
    <id>https://minenet.github.io/2016/05/19/install-jdk-eclipse-pydev-in-ubuntu14-04.html</id>
    <published>2016-05-19T02:33:13.000Z</published>
    <updated>2018-04-19T10:43:50.693Z</updated>
    
    <content type="html"><![CDATA[<p>昨天花了几个小时的时间安装了一个ubuntu虚拟机，配环境，主要是网速太慢。整个安装过程也是出现很多坑，网上的很多配置方法参差不齐，不好使，好在万能的谷歌帮我解决了所有的坑。有必要记录下。</p><h2 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h2><p>VMware workshop Pro + ubuntu keylin14.04<br>安装虚拟机的过程so easy忽略。</p><h2 id="Vim-install"><a href="#Vim-install" class="headerlink" title="Vim install"></a>Vim install</h2><p>初次使用Vim真心不适应，尤其ubuntu自带的tiny版的，所以鄙人进行了卸载，重新安装。   </p><pre><code class="bash">sudo apt-get remove vim-remove ＃ 卸载sudo apt-get install vim  <span class="comment"># install full vim</span></code></pre><h2 id="Root-autologin"><a href="#Root-autologin" class="headerlink" title="Root autologin"></a>Root autologin</h2><p>ubuntu keylin14.04默认登录不是root，可能是为了安全起见。最简单的判断，命令终端符号是<code>$</code>,而不是<code>#</code>。<br>首次使用<code>sudo su</code>命令切换到<code>root</code>，但是每次这样子切换不方便，作为个人本地的虚拟机玩耍，要方便。</p><pre><code class="bash">vim /usr/share/lightdm/lightdm.conf.d/50-ubuntu.conf ＃没有就新建</code></pre><p>50-ubuntu.conf文件</p><pre><code class="bash">[seatDefaults]user-session=ubuntuautologin-user=rootgreeter-session=unity-greetegreeter-show-manual-login=<span class="literal">true</span>allow-guest=<span class="literal">false</span></code></pre><p>重启生效！</p><h2 id="JDK-install"><a href="#JDK-install" class="headerlink" title="JDK install"></a>JDK install</h2><p><a href="http://www.oracle.com/technnetwork/java/javase/downloads" target="_blank" rel="noopener">http://www.oracle.com/technnetwork/java/javase/downloads</a><br>我选择64位<code>jdk-8u91-linux-x64.tar.gz</code></p><pre><code class="bash">tar -zxvf jdk-8u91-linux-x64.tar.gz <span class="comment">#解压</span>cp -R jdk1.8.0_91/ /usr/<span class="built_in">local</span>/   <span class="comment">#copy</span>vim ~/.bashrc <span class="comment">#配置环境变量</span>添加：<span class="built_in">export</span> JAVA_HOME=/usr/<span class="built_in">local</span>/jdk1.8.0_91<span class="built_in">export</span> JAVA_BIN=<span class="variable">$JAVA_HOME</span>/bin<span class="built_in">export</span> JAVA_LIB=<span class="variable">$JAVA_HOME</span>/lib <span class="built_in">export</span> CLASSPATH=.:<span class="variable">$JAVA_LIB</span>/tools.jar:<span class="variable">$JAVA_LIB</span>/dt.jar<span class="built_in">export</span> PATH=<span class="variable">$JAVA_BIN</span>:<span class="variable">$PATH</span><span class="built_in">source</span> ~/.bashrc <span class="comment"># 生效环境变量</span>java -version <span class="comment">#查看是否出现java版本</span>javac</code></pre><h2 id="Eclipse-install"><a href="#Eclipse-install" class="headerlink" title="Eclipse install"></a>Eclipse install</h2><p><a href="http://www.eclipse.org/downloads/" target="_blank" rel="noopener">http://www.eclipse.org/downloads/</a><br>选择了eclipse-jee-mars-2-linux-gtk-x86_64.tar.gz 版本, 解压就可以用。</p><pre><code class="bash">tar -zxvf eclipse-jee-mars-2-linux-gtk-x86_64.tar.gzcp -R eclipse /usr/<span class="built_in">local</span>/</code></pre><p>但是每次启动不方便，需要建立一个桌面快捷键图标。</p><pre><code class="bash">vim /usr/share/applications/eclipse.desktop添加：[Desktop Entry]Name=EclipseComment=Eclipse SDKEncoding=UTF-8Exec=/usr/<span class="built_in">local</span>/eclipse/eclipseIcon=/usr/<span class="built_in">local</span>/eclipse/icon.xpmTerminal=<span class="literal">false</span>StartupNotify=<span class="literal">true</span>Type=ApplicationCategories=Application;Development;</code></pre><p>完成后可以在Application下看到eclipse图标，双击启动，发现<code>No java virtual machine</code>等相关字眼。原因是没有eclipse下jre。 进入eclipse安装目录。</p><pre><code class="bash">mkdir jre<span class="built_in">cd</span> jreln -s /usr/<span class="built_in">local</span>/jdk1.8.0_91/bin bin</code></pre><p>再次双击发现启动了，copy图标到桌面或拉到任务栏上，方便。</p><h2 id="Pydev-install"><a href="#Pydev-install" class="headerlink" title="Pydev install"></a>Pydev install</h2><p>启动eclipse。<br><code>help</code> -&gt; <code>Install New Software</code> -&gt; <code>add</code><br>Name:Pydev<br>locations: <a href="http://pydev.org/updates" target="_blank" rel="noopener">http://pydev.org/updates</a><br>然后一路<code>next</code>。  </p><p>然后配置解析器<br><code>Window</code> -&gt; <code>Preferences</code> 你可以看到<code>Pydev</code> 。<br><code>Interpreter</code> -&gt; <code>Python Interpreter</code> -&gt; <code>New</code><br>Interpreter Name:Python<br>Interpreter Executable:/usr/local/python2.7 (ubuntu默认路径，重新安装者找对应路径)<br>至此安装了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;昨天花了几个小时的时间安装了一个ubuntu虚拟机，配环境，主要是网速太慢。整个安装过程也是出现很多坑，网上的很多配置方法参差不齐，不好使，好在万能的谷歌帮我解决了所有的坑。有必要记录下。&lt;/p&gt;
&lt;h2 id=&quot;Environment&quot;&gt;&lt;a href=&quot;#Environ
      
    
    </summary>
    
      <category term="Linux" scheme="https://minenet.github.io/categories/Linux/"/>
    
    
      <category term="ubuntu" scheme="https://minenet.github.io/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Shadowsocks的搭建</title>
    <link href="https://minenet.github.io/2016/05/10/shadowsocks-node.html"/>
    <id>https://minenet.github.io/2016/05/10/shadowsocks-node.html</id>
    <published>2016-05-10T09:35:55.000Z</published>
    <updated>2018-04-19T10:43:50.692Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Shadowsocks"><a href="#Shadowsocks" class="headerlink" title="Shadowsocks"></a>Shadowsocks</h1><p>Shadowsocks一款代理开源的软件，速度快，多平台使用，灵活代理，国外走代理，国内直接访问。<a href="https://shadowsocks.org/en/index.html" target="_blank" rel="noopener">Shadowsocks</a></p><blockquote><p>If you want to keep a secret, you must also hide it from yourself.</p></blockquote><p>有关于科学上网的东西太多了，VPN、GoAgent、lantern等。相比下来，个人觉得还是SS好用，刚刚接触SS时还是使用了网上别人分享的账号，随着用的人多了，变成龟速（用的多就容易被GFW发现、限制网速，最后直接墙掉）。也用灵雀云的Docker部署SS，不过只能免费用一个月就跪了。今天试着用了几种方式去搭建SS节点，有必要记录下。</p><h1 id="搬瓦工"><a href="#搬瓦工" class="headerlink" title="搬瓦工"></a>搬瓦工</h1><p>搬瓦工<a href="https://bandwagonhost.com" target="_blank" rel="noopener">bandwagon</a>是美国一家卖VPS的站点，为什么这么火，原因有两点：因为便宜，支付方便，直接Alipay；因为傻瓜是操作部署节点，一键搞定；期初的搬瓦工和其他服务器商一样，但是由于其便宜，更多的人去购买VPS，而且更多的人买来搭建SS节点，这公司也很聪明，发现更多的人直接购买了，就开始制定一键生成节点，让更多的人（不会linux）人更方便，尤其是支持支付宝支付更加符合国人。 </p><p>注册账号就不说了，网上搜搜。购买直接进入Control Panel。<br><img src="/image/banwagong1.png" class="img-center"><br>一般个人用的话500G够用，网上很多比较便宜的100G都out of stock了。最便宜的是2.99刀/month,年付更划算，19.99刀/annual 可以跟换数据中心。选洛杉矶数据中心的比较好，延时少，速度快。新出来的费利蒙不知道怎样，尽管都在米国西海岸，而且便宜流量多，不可以更换数据中心（坑）。<br><img src="/image/banwagong2.png" calss="img-center"></p><h1 id="alpharacks"><a href="#alpharacks" class="headerlink" title="alpharacks"></a>alpharacks</h1><p><a href="https://www.alpharacks.com" target="_blank" rel="noopener">alpharacks</a>也是美国一家VPS供应商，数据中心全部在洛杉矶，听说速度还可以，而且比较便宜，唯独不好的是，不像搬瓦工那么土豪使用SSD，选择了使用了HHD，不过好歹自己配置的，实用。整个购买过程也是蛋疼，不支持Alipay，需要使用信用卡或使用PayPal，鄙人逼格很low，信用卡一张都没有，学生党穷鬼。发现强大的Paypal支持国内的借记卡了，有幸试了把，估计也没钱海淘。<a href="https://www.paypal.com" target="_blank" rel="noopener">Paypal</a>  </p><p>注册alpharacks也是坑爹，必须填好国家，而且购买时，必须IP与你注册时国家一致，这个验证真是磨人。其实这个站点没有被墙，不走代理直接访问就好，不然就是Fraud了，无论你怎样购买，无法提交订单。鄙人选择了10美刀一年的，其实有个12美刀的好像更好，流量翻了4倍，内存三倍，反正自己去折腾吧。（鄙人也才开始用，不是做广告推销，有好的便宜的节点，请留言分享啦。谢谢！）</p><h1 id="如何配置"><a href="#如何配置" class="headerlink" title="如何配置"></a>如何配置</h1><p>鄙人选择了centos-6-64bit 系统作为测试配置，SS主要有Python、Go、nodejs、libev等版本，我选择了Python。<br>远程使用xshell登录后。</p><pre><code class="bash">wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.shchmod +x shadowsocks.sh./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log</code></pre><p>中间依次要你输入SS密码，和端口，不输入就是默认。自动安装依赖。  </p><pre><code class="bash">Congratulations, shadowsocks install completed!Your Server IP:your_server_ipYour Server Port:your_server_portYour Password:your_passwordYour Local IP:127.0.0.1Your Local Port:1080Your Encryption Method:aes-256-cfbWelcome to visit:https://teddysun.com/342.htmlEnjoy it!</code></pre><p>当然如果需要更改端口和密码。</p><pre><code class="bash">vi /etc/shadowsocks.json</code></pre><pre><code class="bash">{    <span class="string">"server"</span>:<span class="string">"0.0.0.0"</span>,    <span class="string">"server_port"</span>:8989,    <span class="string">"local_address"</span>:<span class="string">"127.0.0.1"</span>,    <span class="string">"local_port"</span>:1080,    <span class="string">"password"</span>:<span class="string">"yourpassword"</span>,    <span class="string">"timeout"</span>:300,    <span class="string">"method"</span>:<span class="string">"aes-256-cfb"</span>,    <span class="string">"fast_open"</span>: <span class="literal">false</span>}</code></pre><p>多用户设置,直接改上面的json文件如下：  </p><pre><code class="bash">{    <span class="string">"server"</span>:<span class="string">"0.0.0.0"</span>,    <span class="string">"local_address"</span>:<span class="string">"127.0.0.1"</span>,    <span class="string">"local_port"</span>:1080,    <span class="string">"port_password"</span>:{         <span class="string">"8989"</span>:<span class="string">"password0"</span>,         <span class="string">"9001"</span>:<span class="string">"password1"</span>,         <span class="string">"9002"</span>:<span class="string">"password2"</span>,         <span class="string">"9003"</span>:<span class="string">"password3"</span>,         <span class="string">"9004"</span>:<span class="string">"password4"</span>    },    <span class="string">"timeout"</span>:300,    <span class="string">"method"</span>:<span class="string">"aes-256-cfb"</span>,    <span class="string">"fast_open"</span>: <span class="literal">false</span>}</code></pre><p>相关命令：</p><pre><code class="bash">/etc/init.d/shadowsocks start <span class="comment">#开启</span>/etc/init.d/shadowsocks stop  <span class="comment">#停止</span>/etc/init.d/shadowsocks restart <span class="comment">#重启</span>/etc/init.d/shadowsocks status    <span class="comment">#状态</span>./shadowsocks.sh uninstall <span class="comment">#卸载</span>pip install -U shadowsocks <span class="comment">#升级</span></code></pre><p>珍爱生命！远离百度！科学上网！<br><img src="/image/alpharacks.png" class="img-center"><br><img src="/image/google.png" class="img-center"></p><hr><p><a href="https://teddysun.com/357.html" target="_blank" rel="noopener">CentOS下shadowsocks-libev一键安装脚本</a>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Shadowsocks&quot;&gt;&lt;a href=&quot;#Shadowsocks&quot; class=&quot;headerlink&quot; title=&quot;Shadowsocks&quot;&gt;&lt;/a&gt;Shadowsocks&lt;/h1&gt;&lt;p&gt;Shadowsocks一款代理开源的软件，速度快，多平台使用，灵活代
      
    
    </summary>
    
      <category term="Linux" scheme="https://minenet.github.io/categories/Linux/"/>
    
    
      <category term="shadowsocks" scheme="https://minenet.github.io/tags/shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>准确率、精确率和召回率</title>
    <link href="https://minenet.github.io/2016/04/27/classifier-evaulation.html"/>
    <id>https://minenet.github.io/2016/04/27/classifier-evaulation.html</id>
    <published>2016-04-27T06:48:49.000Z</published>
    <updated>2018-04-19T10:43:50.692Z</updated>
    
    <content type="html"><![CDATA[<p>最近一段时间在看NLP相关的Paper，由于初次接触很多相关知识点不是很懂。今天看到有关分类器评价指标的问题。从开始看李航博士的《统计学习方法》，就没有弄明白。今天Google了相关资料。并进行了总结。</p><p>在信息检索领域经常要评价一个分类器的好坏，涉及到三个指标：准确率、精确率、召回率。</p><p><strong>先引出一个常见的问题</strong> </p><p>假如某个班级有男生80人,女生20人,共计100人.目标是找出所有女生.<br>现在某人(相当于分类器)挑选出50个人,其中20人是女生,另外还错误的把30个男生也当作女生挑选出来了。作为评估者的你需要来评估(evaluation)下他的工作。  </p><p><strong>分析问题</strong>  </p><p>某人选择时，目的是选择出所有的女生，结果把30个男生也当做女生选择出来了。对于这次选择，我们得到的相关的人数是20人，不相关的人数是30人。把结果分为四类：TP（true positive）、FP（false positive）、TN（true negative）、FN（false negative）</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">相关（Relevant）、正类</th><th style="text-align:center">不相关（NoneRevelant）、负类</th></tr></thead><tbody><tr><td style="text-align:center">被检索到(Retrieved)</td><td style="text-align:center">TP 20个女生</td><td style="text-align:center">FP，30个被当女生男生</td></tr><tr><td style="text-align:center">未被检索到(Not Retrieved)</td><td style="text-align:center">FN，0</td><td style="text-align:center">TN，50个男生</td></tr></tbody></table><p><strong>准确率（accuracy）</strong></p><blockquote><p>对于给定的测试数据集，分类器正确分类的样本数与总样本数之比.也就是损失函数是0-1损失时测试数据集上的准确率。公式：  </p></blockquote><p>$$ACC = \frac{TP + TN}{TP+TN+FP+FN} \tag{1}$$</p><p>ACC = (20 + 50) / 100 = 70% </p><p><strong>精确率(precision)</strong>  </p><p>精确率是针对依次预测结果而言的，在一次预测中的正样本有多少是真正的正样本。<br>$$P = \frac{TP}{TP + FP} \tag{2}$$<br>P = 20 / (20 + 30) = 40% </p><p><strong>召回率（recall）</strong>  </p><p>召回率是针对样本而言的，样本中的正样本有多少被预测对了。<br>$$R = \frac{TP}{TP + FN} \tag{3}$$<br>R = 20 / 20 = 100%</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近一段时间在看NLP相关的Paper，由于初次接触很多相关知识点不是很懂。今天看到有关分类器评价指标的问题。从开始看李航博士的《统计学习方法》，就没有弄明白。今天Google了相关资料。并进行了总结。&lt;/p&gt;
&lt;p&gt;在信息检索领域经常要评价一个分类器的好坏，涉及到三个指标
      
    
    </summary>
    
      <category term="Machine Learning" scheme="https://minenet.github.io/categories/Machine-Learning/"/>
    
    
      <category term="classifier" scheme="https://minenet.github.io/tags/classifier/"/>
    
  </entry>
  
  <entry>
    <title>2015年总结</title>
    <link href="https://minenet.github.io/2016/04/19/2015-summary.html"/>
    <id>https://minenet.github.io/2016/04/19/2015-summary.html</id>
    <published>2016-04-19T11:40:33.000Z</published>
    <updated>2018-04-19T10:43:50.692Z</updated>
    
    <content type="html"><![CDATA[<p>现在才想起来写总结不知道是一种感觉了。一是说明自己比较懒，二是一个不会学习的人。最近的一些事情让我想起来很多，感觉还是应该去总结，有人说善于总结的人，就善于表达，进步很快。去年博客搭起来后就没怎么写东西，博客很不友好，自己是比较懒，学习的东西也不多，比较零散，总结不出来。是该写点东西了，看了那么多牛人的博客，写了那么多年的博客，纵使很忙的工作，也不忘写博客，不仅仅技术，包括自己的认知和看法。</p><h1 id="2015上半年"><a href="#2015上半年" class="headerlink" title="2015上半年"></a>2015上半年</h1><p>2015年上半年因为考研的失败，也处于一个很纠结的时期，说白了是自己不努力，没规划好自己的学习。大学一晃四年过去了，一心想考研的自己也没考好，面临找工作的时候也很尴尬，自己会什么，技术技术不行，能力能力也不行。年初的三月还是跑了几场宣讲会，很累，但是一点结果都没有，笔试笔试做不出来，面试面试不过关。牛逼的公司连简历都不过关，差的公司又不想去。曾经一起加入一个工作室的同学坚持下来的，都找到了不错的工作，我选择了考研，然而没有努力，欠下的债要还回来的。最后虽然一个做技术的公司收留了我，是上海一家新三板上市的公司，在武汉刚刚成立武汉研发部门，做PHP开发，尽管那时不懂PHP，只会点前端的东西，而且自我感觉写的前端页面好丑。其实那时已经调剂西农来了，找到工作在前。调剂也很纠结的，感觉不太想来这地方读研，尽管是985 211 ，心里还是很有抵触的，一来西农位置好偏僻，二来导师的研究方向很偏，都是农口方向的（就业堪忧）。录取就没管了，当时想着不来也可以，先同意录取。后来公司可以去实习，就去了。四月份时就开始了实习生活，公司离学校比较近，住在学校，每天挤公交去上班。一下子去上班感觉很疲惫，或许是在学校懒散惯了，一下子紧促起来就不习惯了。每天坐在那里写代码，学习东西，完成一些小任务。一个月后，学校老师崔毕业设计（主要是其他原因），走人了，后来还给发了2千多的工资。其实那时感觉在那家公司呆的有点不爽了，工资感觉好低，这个受不了。还是向往南方。</p><p>毕业了，大家都各奔东西，有的去了企业，有的考了公务员，有的继续升学读研。我却有点留恋学校了，寝室最后一个离开学校。后来在离校的前一天有幸被校发展基金会的老师拉去当了一天的学生评委，青年教师授课竞赛，感觉不错，能够在离别时享受一下各个学院的青年教师代表授课，尽管有些课听不懂，还是很nice。离别的前夜，走遍学校的每一处，曾经跑步的操场，西区的火车轨，那些上过课的教室……</p><p>同意录取了后，因为种种原因还是把档案抛向了西农。但心里很有点不甘心的，七月还是跑去了深圳。去深圳开始了漂泊的生活，到处借宿，也开始找工作，当时一起的还有几个同学，几个都考上研究生的同学。开始投简历找工作，其实一开始就接到一个面试通知，就是因为这个面试，我结识了彩石手机的CTO刚哥，刚哥人很不错，天津大学毕业，早年混迹于帝都各大牛逼互联网企业，NoSQL技术专家，创业前任乐视网高级技术经理。后来深创业。那天面试了很久，岗位也是PHP开发工程师，菜鸟的我和大牛的刚哥，很尴尬，聊了两个多小时，提的问题我都不怎么会，为了不尴尬刚哥后来引导我该如何解答，如何学习，后来就聊一些生活。其实蛮投缘的，两个人性格挺像的，本来十点多的面试，结果聊到十二点多，午饭点到了，公司有个人问刚哥吃什么，没想到刚哥要留我吃饭。没好意思，还是婉言谢绝。临走时，他送我到公司外面的电梯门口，甚是欣慰。后来过了两天刚哥给我发微信让我去公司上班，同时HR给我发了录用函。后来因为种种原因还是拒绝了，有点可惜。不过我们并没有这件事情而友尽，因为我们最后成了朋友，他在我的学习中也给了很多指导。现在<a href="http://pingyijinren.com/" target="_blank" rel="noopener">彩石手机</a>逐步壮大,第一款手机即将发布。一份耕耘一分收获。祝走在创业路上的刚哥，更上一层楼！</p><p>浑浑噩噩的度过去了，尽管走过了很多地方，但是似乎自己的心一直没定过，漂浮着。</p><h1 id="2015下半年"><a href="#2015下半年" class="headerlink" title="2015下半年"></a>2015下半年</h1><p>读研的生活，没想象中的那么好，研一的上半年的除了课还是一大堆课，本来从大三开始不喜欢上课的我，顿时没了兴趣，从电子信息工程到软件工程，还是多写点代码好吧，那些所谓的课，很多是仅仅上课之用，过后就再也不会用了。读研很是坎坷，没来之前导师离职了，面临重新的选择导师，开学了，谁要，真是坑。后来在自己坚持下，终于遇到了一个好老师，也是我现在的导师，从现在来看，这是应该我来这边来最大的幸运了。尽管她现在也离职了，去了西工大，但这并不影响她继续指导我，无论科研还是为人，老师都很不错，无论我们有什么困难，都会想办法解决，从来也没有在学生面前拉起一个架子，亦师亦友。从零开始学习文本挖掘，也因此我喜欢上了数据挖掘，只要有目标，什么时候学习都不晚。需要的是加油，需要的是一份坚持的心。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一年晃悠过去了，收获甚微，多的是迷茫，多的是吐槽。现在回过头来，我有什么资本去吐槽？浑浑噩噩结果是更糟糕，当再次面临找工作时，拿什么资本去PK，两年的时间很快，学不学得到东西关键在于自己，不在于学校，不在于老师，别拿时光混学历，你混不起！</p><h1 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h1><ol><li>坚持写博客，至少一周一篇。</li><li>多读书，读好书，完成读书计划。</li><li>坚持上<a href="https://www.coursera.org" target="_blank" rel="noopener">Coursera</a>，按时提交作业。</li><li>坚持写算法。</li><li>养成早睡早起的好习惯。</li><li>少花费时间在空间，微博，知乎上，多上<a href="https://www.v2ex.com/" target="_blank" rel="noopener">V2EX</a>。</li><li>尝试着去<a href="http://stackoverflow.com/" target="_blank" rel="noopener">StackOverflow</a>回答问题。</li><li>多多看看英文的文章。</li></ol><p><img src="/image/qingchunbuhui.jpeg" class="img-center"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在才想起来写总结不知道是一种感觉了。一是说明自己比较懒，二是一个不会学习的人。最近的一些事情让我想起来很多，感觉还是应该去总结，有人说善于总结的人，就善于表达，进步很快。去年博客搭起来后就没怎么写东西，博客很不友好，自己是比较懒，学习的东西也不多，比较零散，总结不出来。是
      
    
    </summary>
    
      <category term="Summary" scheme="https://minenet.github.io/categories/Summary/"/>
    
    
      <category term="2015" scheme="https://minenet.github.io/tags/2015/"/>
    
  </entry>
  
  <entry>
    <title>Git command</title>
    <link href="https://minenet.github.io/2016/04/07/git-command.html"/>
    <id>https://minenet.github.io/2016/04/07/git-command.html</id>
    <published>2016-04-07T14:14:02.000Z</published>
    <updated>2018-04-19T10:43:50.691Z</updated>
    
    <content type="html"><![CDATA[<h1 id="What’s-git"><a href="#What’s-git" class="headerlink" title="What’s git ?"></a>What’s git ?</h1><p><strong>Git</strong>一种分布式版本控制系统，也是现今最流行的版本控制系统，使用于各大互联网公司。这是官方的介绍：</p><blockquote><p>Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency.</p></blockquote><h1 id="Git-command"><a href="#Git-command" class="headerlink" title="Git command"></a>Git command</h1><table><thead><tr><th style="text-align:left">comand</th><th style="text-align:left">function</th></tr></thead><tbody><tr><td style="text-align:left">$ git init</td><td style="text-align:left">git初始化</td></tr><tr><td style="text-align:left">$ git add .</td><td style="text-align:left">将修改增加到缓存区</td></tr><tr><td style="text-align:left">$ git commit “”</td><td style="text-align:left">将存到缓存区的内容提交到git</td></tr><tr><td style="text-align:left">$ git log</td><td style="text-align:left">查看历史操作记录</td></tr><tr><td style="text-align:left">$ git status</td><td style="text-align:left">查看当前状态</td></tr><tr><td style="text-align:left">$ git reflog</td><td style="text-align:left">查看历史命令</td></tr><tr><td style="text-align:left">$ git log –pretty=oneline</td><td style="text-align:left">横向显示历史记录（当记录比较多时）</td></tr><tr><td style="text-align:left">$ git reset –hard HEAD^</td><td style="text-align:left">退回上一个版本，^^上上个版本，~10退回到第10个版本，filename把filename暂存区的修改回退到工作区</td></tr><tr><td style="text-align:left">$ git diff filename</td><td style="text-align:left">查看文件修改的记录</td></tr><tr><td style="text-align:left">$ git checkout file</td><td style="text-align:left">切换到分支</td></tr><tr><td style="text-align:left">$ git checkout –”fielname”</td><td style="text-align:left">撤销工作区的修改, 也可以用于误删文件，版本库替换工作区</td></tr><tr><td style="text-align:left">$ rm filename</td><td style="text-align:left">删除文件</td></tr><tr><td style="text-align:left">$ git rm filename</td><td style="text-align:left">从版本库中删除文件</td></tr><tr><td style="text-align:left">$ git branch file</td><td style="text-align:left">创建分支</td></tr><tr><td style="text-align:left">$ git branch</td><td style="text-align:left">查看当前分支</td></tr><tr><td style="text-align:left">$ git merge file</td><td style="text-align:left">合并指定分支到当前分支</td></tr><tr><td style="text-align:left">$ git branch -d file</td><td style="text-align:left">删除分支</td></tr><tr><td style="text-align:left">$ git log –graph</td><td style="text-align:left">查看合并分支图</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;What’s-git&quot;&gt;&lt;a href=&quot;#What’s-git&quot; class=&quot;headerlink&quot; title=&quot;What’s git ?&quot;&gt;&lt;/a&gt;What’s git ?&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Git&lt;/strong&gt;一种分布式版本控制系统，也是
      
    
    </summary>
    
      <category term="Linux" scheme="https://minenet.github.io/categories/Linux/"/>
    
    
      <category term="git" scheme="https://minenet.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>如何优雅的写数学公式（MathJax）</title>
    <link href="https://minenet.github.io/2016/04/05/how-to-use-mathjax.html"/>
    <id>https://minenet.github.io/2016/04/05/how-to-use-mathjax.html</id>
    <published>2016-04-04T16:02:08.000Z</published>
    <updated>2018-04-19T10:43:50.691Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是Mathjs"><a href="#什么是Mathjs" class="headerlink" title="什么是Mathjs"></a>什么是Mathjs</h1><p>对于一个工科生难免的会面临数学公式的书写，常常我们使用的mathtype，但是这个是写好后一图片形式粘贴上去，及其low。不可能每个数学公式都从别的地方粘贴过来，再说了图片的东西打印出来那真是一个模糊，难免让你的作品（论文和文章）让人看起来像copy。最近学院某大牛教授，跟学院的学生讲解了两个半天的如何使用Latex，可惜的是鄙人没能去听，事后看了看PPT还是很nice的，Latex有软件，在里面软件进行论文的排版更好。今天我想在网页上如何使用嵌入数学公式，一个强大的插件出现——mathJax，它允许你在你的网页中书写公式，无论你是使用Latex还是MathML或者AsciiMath符号，这些mathjax都可以帮你实现，便捷轻松。直接上码：  </p><pre><code>\begin{equation}x^{y^z}=(1+{\rm e}^x{-2xy^w})\label{1}\end{equation}</code></pre><p>上面的公式代码展示如下：<br>\begin{equation}x^{y^z}=(1+{\rm e}^x{-2xy^w})\label{1}\end{equation}<br>效果不用说,再来个复杂点的数学公式：</p><pre><code class="bash">\begin{equation}\frac{\partial u}{\partial t} = \left(\frac{\partial^2 u}{\partial x^2}+\frac{\partial^2 u}{\partial y^2} + \frac{\partial^2 u}{\partial z^2}\right)\label{2}\end{equation}</code></pre><p>display:<br>\begin{equation} \frac{\partial u}{\partial t} =  \left( \frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2} + \frac{\partial^2 u}{\partial z^2}\right) \label{2} \end{equation}<br>感觉很炫！老师再也不用担心我写不好数学公式了。而且还很优雅的在公式末尾使用了公式的编号，加编号是为了更好的引用，比如说我们要使用<code>（1）</code>公式，没必要重新写，使用<code>$\eqref{1}$</code>即可。example: 例如我们使用公式$\eqref{1}$去……<br>怎么实现自动加编号，只需要加一段js代码即可：  </p><pre><code class="js">&lt;script type=<span class="string">"text/x-mathjax-config"</span>&gt;  MathJax.Hub.Config({  TeX: {<span class="attr">equationNumbers</span>: { <span class="attr">autoNumber</span>: <span class="string">"AMS"</span> } }});&lt;<span class="regexp">/script&gt;</span></code></pre><p>当你本页面的公式鼠标右键可以展示公式代码。将代码复制到word里面也能实现公式。</p><h1 id="参考学习"><a href="#参考学习" class="headerlink" title="参考学习"></a>参考学习</h1><p><a href="http://iori.sinaapp.com/17.html/comment-page-1?replytocom=2" target="_blank" rel="noopener">MathJax使用LaTeX语法编写数学公式教程</a><br>有时间一定好好翻译一下<a href="http://www.onemathematicalcat.org/MathJaxDocumentation/TeXSyntax.htm" target="_blank" rel="noopener">MathJaxDocumentation</a><br>other: 一款强大的编辑器，不仅涉及数学而且还支持物理化学。<a href="http://www.jmeditor.com/jme/intr.html" target="_blank" rel="noopener">JMEditor</a>：</p><blockquote><p>JMEditor（JavaScript Math Editor）是基于CKEditor、jQuery、MathQuill等组件开发的，轻量级、开放源代码、所见即所得、无任何插件的在线公式编辑器。CKEditor与jQuery应用的十分广泛，不再过多介绍。需要指出的是MathQuill，使用HTML+CSS+JS实现公式编辑的效果，他把DOM的力量发挥到了极致。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是Mathjs&quot;&gt;&lt;a href=&quot;#什么是Mathjs&quot; class=&quot;headerlink&quot; title=&quot;什么是Mathjs&quot;&gt;&lt;/a&gt;什么是Mathjs&lt;/h1&gt;&lt;p&gt;对于一个工科生难免的会面临数学公式的书写，常常我们使用的mathtype，但是这个是
      
    
    </summary>
    
      <category term="Math" scheme="https://minenet.github.io/categories/Math/"/>
    
    
      <category term="mathjs" scheme="https://minenet.github.io/tags/mathjs/"/>
    
  </entry>
  
  <entry>
    <title>hexo中如何在多台PC中部署</title>
    <link href="https://minenet.github.io/2016/04/04/how-to-deploy-in-differernt-pc.html"/>
    <id>https://minenet.github.io/2016/04/04/how-to-deploy-in-differernt-pc.html</id>
    <published>2016-04-04T06:38:40.000Z</published>
    <updated>2018-04-19T10:43:50.691Z</updated>
    
    <content type="html"><![CDATA[<p>最近几天把博客进行了重构，之前在阿里云部署的thinkjs+easyou博客很不友好，各种<code>bug</code>，尤其是对代码支持和blog文章的格式。Blog选择了流行的hexo+jacman，并最后优雅的使用了Markdown，真是爽极了。</p><h1 id="如何安装使用hexo-jacman"><a href="#如何安装使用hexo-jacman" class="headerlink" title="如何安装使用hexo+jacman"></a>如何安装使用hexo+jacman</h1><p>关于如何安装，由于hexo是基于nodejs，速度很快。用的很多，安装首先安装<code>nodejs</code>，然后依次安装<code>npm</code>和<code>hexo</code>。至于步骤网上已经很多了。这里附上一个<a href="http://wuchong.me/blog/2014/11/20/how-to-use-jacman/" target="_blank" rel="noopener">如何使用jacman主题</a>。按照上面的步骤一步步走。这里就不多说了。</p><h1 id="如何部署在多台电脑中deploy"><a href="#如何部署在多台电脑中deploy" class="headerlink" title="如何部署在多台电脑中deploy"></a>如何部署在多台电脑中deploy</h1><h2 id="利用git管理blog"><a href="#利用git管理blog" class="headerlink" title="利用git管理blog"></a>利用git管理blog</h2><p>网上有部分资源可以利用但是不是很全，这次学习了多篇大牛的博客才明白，中间出现过坑（PS：鄙人是初学者，大牛求轻拍！），不过度都解决了。  </p><p>按照jacman主题的安装，我们已经将Blog部署上去<code>github</code>上了, 当登录github时，发现，全部是渲染后的结果，不符合我们的预期。如何利用github管理博客源代码和渲染展示的博客。大致思路是利用repository中的username.github.io仓库，利用了两个分支，一个master分支，一个是source分支，一个放源代码一个放渲染。 </p><ol><li>我们在本地的blog根目录下，利用<code>git init</code>命令进行初始化仓库。然后进行如下命令:  <pre><code class="bash">$ git add .  ＃存到缓存区$ git commit -am <span class="string">"commit blog"</span> ＃提交</code></pre></li><li>建立source分支，并将源代码push到github。 <pre><code class="bash">$ git branch <span class="built_in">source</span> ＃创建<span class="built_in">source</span>     $ git checkout <span class="built_in">source</span> ＃切换到分支    $ git remote -v ＃查看远程分支    $ git push origin <span class="built_in">source</span></code></pre>注意：在我们推之前我们首先要删除<code>theme/jacma</code>下的<code>.git</code>文件，该文件夹是隐藏的，显示隐藏后删除，不然push不上去。<br>其实很多技术博客中需要修改blog根目录下的<code>.gitignore</code>文件，其实这与版本的不同有关系，我的版本中就不用修改，不过最好事先查看。需要添加<code>public/</code>和<code>.deploy*/</code> ，因为这两个文件每次部署时都会生成。没必要<code>push</code>上去，我的<code>.gitignore</code>文件：  <pre><code class="bash">.DS_StoreThumbs.dbdb.json*.<span class="built_in">log</span>node_modules/public/.deploy*/</code></pre>3.完成上去过程后，这就完成了github管理hexo源代码。如果我们想在另一台电脑写博客，比如刚刚我们在公司的电脑上部署好了，回家了突发灵感，要写，对于没有后台的hexo来说，就有点尴尬了，不过还好有强大的github。<br>在新的电脑B中，我们也时先安装nodejs，npm，hexo，添加ssh，然后与远程的source分支进行绑定，这样子我们就完成了两台部署，第三台也是这样子。    <pre><code class="bash">$ git <span class="built_in">clone</span> -b <span class="built_in">source</span> git@github.com:username/username.github.io.git</code></pre><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2>在任何已经部署完成的电脑中，首先我们得pull最新的分支，master和source，然后push，这样子会有很多步骤需要做。如果玩过shell编程的都知道，把这些写成shell脚本，自动执行是不是很nice。<br>编辑两个文件，一个fetch.sh,一个submit.sh。<br>fetch文件：<pre><code class="bash">＃File Name: fetch.sh＃!/bin/bashgit pull origin <span class="built_in">source</span><span class="built_in">cd</span> .deploy_git/git pull</code></pre>submit文件：<pre><code class="bash">＃File Name: submit.sh＃!/bin/bashhexo d -ggit add .git commit -am <span class="string">"update blog source"</span>git push origin <span class="built_in">source</span></code></pre>每次编辑之前，先运行fetch.sh,执行代码<code>./fetch.sh</code>,编辑完结束，然后就运行<code>./submit.sh</code>,一切okay。中间如果出现有需要输入密码的情况，那是因为你在添加ssh key时设置了秘钥，其实无秘钥部署更nice，设置密码时直接回车两次就默认密码为空了，方便不少。<br>如有问题Google和issue。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近几天把博客进行了重构，之前在阿里云部署的thinkjs+easyou博客很不友好，各种&lt;code&gt;bug&lt;/code&gt;，尤其是对代码支持和blog文章的格式。Blog选择了流行的hexo+jacman，并最后优雅的使用了Markdown，真是爽极了。&lt;/p&gt;
&lt;h1 i
      
    
    </summary>
    
      <category term="Blog" scheme="https://minenet.github.io/categories/Blog/"/>
    
    
      <category term="hexo" scheme="https://minenet.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
